#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Apr 27 12:02:14 2017 by generateDS.py version 2.25a.
#
# Command line options:
#   ('-o', '/home/achavez/Documentos/Desarrollo/Proyectos/IUSA/CFDI_33_comp.py')
#
# Command line arguments:
#   /home/achavez/Documentos/Desarrollo/Proyectos/IUSA/cfdv33.xsd
#
# Command line:
#   generateDS.py -o "/home/achavez/Documentos/Desarrollo/Proyectos/IUSA/CFDI_33_comp.py" /home/achavez/Documentos/Desarrollo/Proyectos/IUSA/cfdv33.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.25a0
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name, pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0, optional=0):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Comprobante(GeneratedsSuper):
    """Estándar de Comprobante Fiscal Digital por Internet.Atributo
    requerido con valor prefijado a 3.3 que indica la versión del
    estándar bajo el que se encuentra expresado el
    comprobante.Atributo opcional para precisar la serie para
    control interno del contribuyente. Este atributo acepta una
    cadena de caracteres.Atributo opcional para control interno del
    contribuyente que expresa el folio del comprobante, acepta una
    cadena de caracteres.Atributo requerido para la expresión de la
    fecha y hora de expedición del Comprobante Fiscal Digital por
    Internet. Se expresa en la forma AAAA-MM-DDThh:mm:ss y debe
    corresponder con la hora local donde se expide el
    comprobante.Atributo requerido para contener el sello digital
    del comprobante fiscal, al que hacen referencia las reglas de
    resolución miscelánea vigente. El sello debe ser expresado como
    una cadena de texto en formato Base 64.Atributo condicional para
    expresar la clave de la forma de pago de los bienes o servicios
    amparados por el comprobante, Si no se conoce la forma de pago
    este atributo se debe omitir.Atributo requerido para expresar el
    número de serie del certificado de sello digital que ampara al
    comprobante, de acuerdo con el acuse correspondiente a 20
    posiciones otorgado por el sistema del SAT.Atributo requerido
    que sirve para incorporar el certificado de sello digital que
    ampara al comprobante, como texto en formato base 64.Atributo
    condicional para expresar las condiciones comerciales aplicables
    para el pago del comprobante fiscal digital por Internet. Este
    atributo puede ser condicionado mediante atributos o
    complementos.Atributo requerido para representar la suma de los
    importes de los conceptos antes de descuentos e impuesto. No se
    permiten valores negativos.Atributo condicional para representar
    el importe total de los descuentos aplicables antes de
    impuestos. No se permiten valores negativos. Se debe registrar
    cuando existan conceptos con descuento.Atributo requerido para
    identificar la clave de la moneda utilizada para expresar los
    montos, cuando se usa moneda nacional se registra MXN. Conforme
    con la especificación ISO 4217.Atributo condicional para
    representar el tipo de cambio conforme con la moneda usada. Es
    requerido cuando la clave de moneda es distinta de MXN y de XXX.
    El valor debe reflejar el número de pesos mexicanos que
    equivalen a una unidad de la divisa señalada en el atributo
    moneda. Si el valor está fuera del porcentaje aplicable a la
    moneda tomado del catálogo c_Moneda, el emisor debe obtener del
    PAC que vaya a timbrar el CFDI, de manera no automática, una
    clave de confirmación para ratificar que el valor es correcto e
    integrar dicha clave en el atributo Confirmacion.Atributo
    requerido para representar la suma del subtotal, menos los
    descuentos aplicables, más las contribuciones recibidas
    (impuestos trasladados - federales o locales, derechos,
    productos, aprovechamientos, aportaciones de seguridad social,
    contribuciones de mejoras) menos los impuestos retenidos. Si el
    valor es superior al límite que establezca el SAT en la
    Resolución Miscelánea Fiscal vigente, el emisor debe obtener del
    PAC que vaya a timbrar el CFDI, de manera no automática, una
    clave de confirmación para ratificar que el valor es correcto e
    integrar dicha clave en el atributo Confirmacion. No se permiten
    valores negativos.Atributo requerido para expresar la clave del
    efecto del comprobante fiscal para el contribuyente
    emisor.Atributo condicional para precisar la clave del método de
    pago que aplica para este comprobante fiscal digital por
    Internet, conforme al Artículo 29-A fracción VII incisos a y b
    del CFF.Atributo requerido para incorporar el código postal del
    lugar de expedición del comprobante (domicilio de la matriz o de
    la sucursal).Atributo condicional para registrar la clave de
    confirmación que entregue el PAC para expedir el comprobante con
    importes grandes, con un tipo de cambio fuera del rango
    establecido o con ambos casos. Es requerido cuando se registra
    un tipo de cambio o un total fuera del rango establecido."""
    subclass = None
    superclass = None
    def __init__(self, Version=None, Serie=None, Folio=None, Fecha=None, Sello=None, FormaPago=None, NoCertificado=None, Certificado=None, CondicionesDePago=None, SubTotal=None, Descuento=None, Moneda=None, TipoCambio=None, Total=None, TipoDeComprobante=None, MetodoPago=None, LugarExpedicion=None, Confirmacion=None, CfdiRelacionados=None, Emisor=None, Receptor=None, Conceptos=None, Impuestos=None, Complemento=None, Addenda=None, ns_=None):
        self.original_tagname_ = None
        self.Version = _cast(None, Version)
        self.Serie = _cast(None, Serie)
        self.Folio = _cast(None, Folio)
        self.Fecha = _cast(None, Fecha)
        self.Sello = _cast(None, Sello)
        self.FormaPago = _cast(None, FormaPago)
        self.NoCertificado = _cast(None, NoCertificado)
        self.Certificado = _cast(None, Certificado)
        self.CondicionesDePago = _cast(None, CondicionesDePago)
        self.SubTotal = _cast(None, SubTotal)
        self.Descuento = _cast(None, Descuento)
        self.Moneda = _cast(None, Moneda)
        #self.TipoCambio = _cast(float, TipoCambio)
        self.TipoCambio = _cast(None, TipoCambio)
        self.Total = _cast(None, Total)
        self.TipoDeComprobante = _cast(None, TipoDeComprobante)
        self.MetodoPago = _cast(None, MetodoPago)
        self.LugarExpedicion = _cast(None, LugarExpedicion)
        self.Confirmacion = _cast(None, Confirmacion)
        self.CfdiRelacionados = CfdiRelacionados
        self.Emisor = Emisor
        self.Receptor = Receptor
        self.Conceptos = Conceptos
        self.Impuestos = Impuestos
        self.Complemento = Complemento
        self.Addenda = Addenda
        self.ns_ = ns_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Comprobante)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Comprobante.subclass:
            return Comprobante.subclass(*args_, **kwargs_)
        else:
            return Comprobante(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CfdiRelacionados(self): return self.CfdiRelacionados
    def set_CfdiRelacionados(self, CfdiRelacionados): self.CfdiRelacionados = CfdiRelacionados
    def get_Emisor(self): return self.Emisor
    def set_Emisor(self, Emisor): self.Emisor = Emisor
    def get_Receptor(self): return self.Receptor
    def set_Receptor(self, Receptor): self.Receptor = Receptor
    def get_Conceptos(self): return self.Conceptos
    def set_Conceptos(self, Conceptos): self.Conceptos = Conceptos
    def get_Impuestos(self): return self.Impuestos
    def set_Impuestos(self, Impuestos): self.Impuestos = Impuestos
    def get_Complemento(self): return self.Complemento
    def set_Complemento(self, Complemento): self.Complemento = Complemento
    def get_Addenda(self): return self.Addenda
    def set_Addenda(self, Addenda): self.Addenda = Addenda
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Serie(self): return self.Serie
    def set_Serie(self, Serie): self.Serie = Serie
    def get_Folio(self): return self.Folio
    def set_Folio(self, Folio): self.Folio = Folio
    def get_Fecha(self): return self.Fecha
    def set_Fecha(self, Fecha): self.Fecha = Fecha
    def get_Sello(self): return self.Sello
    def set_Sello(self, Sello): self.Sello = Sello
    def get_FormaPago(self): return self.FormaPago
    def set_FormaPago(self, FormaPago): self.FormaPago = FormaPago
    def get_NoCertificado(self): return self.NoCertificado
    def set_NoCertificado(self, NoCertificado): self.NoCertificado = NoCertificado
    def get_Certificado(self): return self.Certificado
    def set_Certificado(self, Certificado): self.Certificado = Certificado
    def get_CondicionesDePago(self): return self.CondicionesDePago
    def set_CondicionesDePago(self, CondicionesDePago): self.CondicionesDePago = CondicionesDePago
    def get_SubTotal(self): return self.SubTotal
    def set_SubTotal(self, SubTotal): self.SubTotal = SubTotal
    def get_Descuento(self): return self.Descuento
    def set_Descuento(self, Descuento): self.Descuento = Descuento
    def get_Moneda(self): return self.Moneda
    def set_Moneda(self, Moneda): self.Moneda = Moneda
    def get_TipoCambio(self): return self.TipoCambio
    def set_TipoCambio(self, TipoCambio): self.TipoCambio = TipoCambio
    def get_Total(self): return self.Total
    def set_Total(self, Total): self.Total = Total
    def get_TipoDeComprobante(self): return self.TipoDeComprobante
    def set_TipoDeComprobante(self, TipoDeComprobante): self.TipoDeComprobante = TipoDeComprobante
    def get_MetodoPago(self): return self.MetodoPago
    def set_MetodoPago(self, MetodoPago): self.MetodoPago = MetodoPago
    def get_LugarExpedicion(self): return self.LugarExpedicion
    def set_LugarExpedicion(self, LugarExpedicion): self.LugarExpedicion = LugarExpedicion
    def get_Confirmacion(self): return self.Confirmacion
    def set_Confirmacion(self, Confirmacion): self.Confirmacion = Confirmacion
    def hasContent_(self):
        if (
            self.CfdiRelacionados is not None or
            self.Emisor is not None or
            self.Receptor is not None or
            self.Conceptos is not None or
            self.Impuestos is not None or
            self.Complemento is not None or
            self.Addenda is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='Comprobante', namespacedef_='', pretty_print=True, namespace_complement_=''):
        self.namespace_complement_ = namespace_complement_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        namespacedef_ = self.ns_
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Comprobante')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='Comprobante', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='Comprobante'):
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            outfile.write(' Version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Version), input_name='Version')), ))
        if self.Serie is not None and 'Serie' not in already_processed:
            already_processed.add('Serie')
            outfile.write(' Serie=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Serie), input_name='Serie')), ))
        if self.Folio is not None and 'Folio' not in already_processed:
            already_processed.add('Folio')
            outfile.write(' Folio=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Folio), input_name='Folio')), ))
        if self.Fecha is not None and 'Fecha' not in already_processed:
            already_processed.add('Fecha')
            outfile.write(' Fecha=%s' % (quote_attrib(self.Fecha), ))
        if self.Sello is not None and 'Sello' not in already_processed:
            already_processed.add('Sello')
            outfile.write(' Sello=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Sello), input_name='Sello')), ))
        if self.FormaPago is not None and 'FormaPago' not in already_processed:
            already_processed.add('FormaPago')
            outfile.write(' FormaPago=%s' % (quote_attrib(self.FormaPago), ))
        if self.NoCertificado is not None and 'NoCertificado' not in already_processed:
            already_processed.add('NoCertificado')
            outfile.write(' NoCertificado=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NoCertificado), input_name='NoCertificado')), ))
        if self.Certificado is not None and 'Certificado' not in already_processed:
            already_processed.add('Certificado')
            outfile.write(' Certificado=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Certificado), input_name='Certificado')), ))
        if self.CondicionesDePago is not None and 'CondicionesDePago' not in already_processed:
            already_processed.add('CondicionesDePago')
            outfile.write(' CondicionesDePago=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CondicionesDePago), input_name='CondicionesDePago')), ))
        if self.SubTotal is not None and 'SubTotal' not in already_processed:
            already_processed.add('SubTotal')
            outfile.write(' SubTotal=%s' % (quote_attrib(self.SubTotal), ))
        if self.Descuento is not None and 'Descuento' not in already_processed:
            already_processed.add('Descuento')
            outfile.write(' Descuento=%s' % (quote_attrib(self.Descuento), ))
        if self.Moneda is not None and 'Moneda' not in already_processed:
            already_processed.add('Moneda')
            outfile.write(' Moneda=%s' % (quote_attrib(self.Moneda), ))
        if self.TipoCambio is not None and 'TipoCambio' not in already_processed:
            already_processed.add('TipoCambio')
            #outfile.write(' TipoCambio="%s"' % self.gds_format_float(self.TipoCambio, input_name='TipoCambio'))
            outfile.write(' TipoCambio=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.TipoCambio), input_name='TipoCambio')), ))
        if self.Total is not None and 'Total' not in already_processed:
            already_processed.add('Total')
            outfile.write(' Total=%s' % (quote_attrib(self.Total), ))
        if self.TipoDeComprobante is not None and 'TipoDeComprobante' not in already_processed:
            already_processed.add('TipoDeComprobante')
            outfile.write(' TipoDeComprobante=%s' % (quote_attrib(self.TipoDeComprobante), ))
        if self.MetodoPago is not None and 'MetodoPago' not in already_processed:
            already_processed.add('MetodoPago')
            outfile.write(' MetodoPago=%s' % (quote_attrib(self.MetodoPago), ))
        if self.LugarExpedicion is not None and 'LugarExpedicion' not in already_processed:
            already_processed.add('LugarExpedicion')
            outfile.write(' LugarExpedicion=%s' % (quote_attrib(self.LugarExpedicion), ))
        if self.Confirmacion is not None and 'Confirmacion' not in already_processed:
            already_processed.add('Confirmacion')
            outfile.write(' Confirmacion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Confirmacion), input_name='Confirmacion')), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='Comprobante', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CfdiRelacionados is not None:
            self.CfdiRelacionados.export(outfile, level, namespace_, name_='CfdiRelacionados', pretty_print=pretty_print)
        if self.Emisor is not None:
            self.Emisor.export(outfile, level, namespace_, name_='Emisor', pretty_print=pretty_print)
        if self.Receptor is not None:
            self.Receptor.export(outfile, level, namespace_, name_='Receptor', pretty_print=pretty_print)
        if self.Conceptos is not None:
            self.Conceptos.export(outfile, level, namespace_, name_='Conceptos', pretty_print=pretty_print)
        if self.Impuestos is not None:
            self.Impuestos.export(outfile, level, namespace_, name_='Impuestos', pretty_print=pretty_print)
        if self.Complemento is not None:
            self.Complemento.export(outfile, level, namespace_, name_='Complemento', pretty_print=pretty_print, namespace_complement_=self.namespace_complement_)
        if self.Addenda is not None:
            self.Addenda.export(outfile, level, namespace_, name_='Addenda', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Version', node)
        if value is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            self.Version = value
        value = find_attr_value_('Serie', node)
        if value is not None and 'Serie' not in already_processed:
            already_processed.add('Serie')
            self.Serie = value
        value = find_attr_value_('Folio', node)
        if value is not None and 'Folio' not in already_processed:
            already_processed.add('Folio')
            self.Folio = value
        value = find_attr_value_('Fecha', node)
        if value is not None and 'Fecha' not in already_processed:
            already_processed.add('Fecha')
            self.Fecha = value
        value = find_attr_value_('Sello', node)
        if value is not None and 'Sello' not in already_processed:
            already_processed.add('Sello')
            self.Sello = value
        value = find_attr_value_('FormaPago', node)
        if value is not None and 'FormaPago' not in already_processed:
            already_processed.add('FormaPago')
            self.FormaPago = value
        value = find_attr_value_('NoCertificado', node)
        if value is not None and 'NoCertificado' not in already_processed:
            already_processed.add('NoCertificado')
            self.NoCertificado = value
        value = find_attr_value_('Certificado', node)
        if value is not None and 'Certificado' not in already_processed:
            already_processed.add('Certificado')
            self.Certificado = value
        value = find_attr_value_('CondicionesDePago', node)
        if value is not None and 'CondicionesDePago' not in already_processed:
            already_processed.add('CondicionesDePago')
            self.CondicionesDePago = value
        value = find_attr_value_('SubTotal', node)
        if value is not None and 'SubTotal' not in already_processed:
            already_processed.add('SubTotal')
            self.SubTotal = value
        value = find_attr_value_('Descuento', node)
        if value is not None and 'Descuento' not in already_processed:
            already_processed.add('Descuento')
            self.Descuento = value
        value = find_attr_value_('Moneda', node)
        if value is not None and 'Moneda' not in already_processed:
            already_processed.add('Moneda')
            self.Moneda = value
        value = find_attr_value_('TipoCambio', node)
        if value is not None and 'TipoCambio' not in already_processed:
            already_processed.add('TipoCambio')
            try:
                self.TipoCambio = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (TipoCambio): %s' % exp)
        value = find_attr_value_('Total', node)
        if value is not None and 'Total' not in already_processed:
            already_processed.add('Total')
            self.Total = value
        value = find_attr_value_('TipoDeComprobante', node)
        if value is not None and 'TipoDeComprobante' not in already_processed:
            already_processed.add('TipoDeComprobante')
            self.TipoDeComprobante = value
        value = find_attr_value_('MetodoPago', node)
        if value is not None and 'MetodoPago' not in already_processed:
            already_processed.add('MetodoPago')
            self.MetodoPago = value
        value = find_attr_value_('LugarExpedicion', node)
        if value is not None and 'LugarExpedicion' not in already_processed:
            already_processed.add('LugarExpedicion')
            self.LugarExpedicion = value
        value = find_attr_value_('Confirmacion', node)
        if value is not None and 'Confirmacion' not in already_processed:
            already_processed.add('Confirmacion')
            self.Confirmacion = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CfdiRelacionados':
            obj_ = CfdiRelacionadosType.factory()
            obj_.build(child_)
            self.CfdiRelacionados = obj_
            obj_.original_tagname_ = 'CfdiRelacionados'
        elif nodeName_ == 'Emisor':
            obj_ = EmisorType.factory()
            obj_.build(child_)
            self.Emisor = obj_
            obj_.original_tagname_ = 'Emisor'
        elif nodeName_ == 'Receptor':
            obj_ = ReceptorType.factory()
            obj_.build(child_)
            self.Receptor = obj_
            obj_.original_tagname_ = 'Receptor'
        elif nodeName_ == 'Conceptos':
            obj_ = ConceptosType.factory()
            obj_.build(child_)
            self.Conceptos = obj_
            obj_.original_tagname_ = 'Conceptos'
        elif nodeName_ == 'Impuestos':
            obj_ = ImpuestosType2.factory()
            obj_.build(child_)
            self.Impuestos = obj_
            obj_.original_tagname_ = 'Impuestos'
        elif nodeName_ == 'Complemento':
            obj_ = ComplementoType.factory()
            obj_.build(child_)
            self.Complemento = obj_
            obj_.original_tagname_ = 'Complemento'
        elif nodeName_ == 'Addenda':
            obj_ = AddendaType.factory()
            obj_.build(child_)
            self.Addenda = obj_
            obj_.original_tagname_ = 'Addenda'
# end class Comprobante


class ComercioExterior(GeneratedsSuper):
    """Complemento para incorporar la información en el caso de Exportación
    de Mercancías en definitiva.Atributo requerido que indica la
    versión del complemento.Atributo condicional que indica la clave
    del motivo por el cual en la exportación de mercancías en
    definitiva con clave de pedimento A1, éstas no son objeto de
    enajenación o siéndolo sean a título gratuito, desde el
    domicilio del emisor hacia el domicilio del receptor o del
    destinatario. La clave del motivo es conforme con el catálogo
    c_MotivoTraslado publicado en el portal del SAT en
    internet.Atributo requerido que indica la clave del tipo de
    operación de Comercio Exterior que se realiza, conforme con el
    catálogo c_TipoOperacion publicado en el portal del SAT en
    internet.Atributo condicional que indica la clave de pedimento
    que se haya declarado conforme con el catálogo c_ClavePedimento
    publicado en el portal del SAT en internet.Atributo condicional
    derivado de la excepción de certificados de Origen de los
    Tratados de Libre Comercio que ha celebrado México con diversos
    países. 0 = No Funge como certificado de origen 1 = Funge como
    certificado de origen.Atributo condicional para expresar el
    folio del certificado de origen o el folio fiscal del CFDI con
    el que se pagó la expedición del certificado de origen.Atributo
    condicional que indica el número de exportador confiable,
    conforme al artículo 22 del Anexo 1 del Tratado de Libre
    Comercio con la Asociación Europea y a la Decisión de la
    Comunidad Europea.Atributo condicional que indica la clave del
    INCOTERM aplicable a la factura, conforme con el catálogo
    c_INCOTERM publicado en el portal del SAT en internet.Atributo
    condicional que indica si la factura tiene o no subdivisión.
    Valores posibles: 0 - no tiene subdivisión,1 - si tiene
    subdivisión.Atributo opcional en caso de ingresar alguna
    información adicional, como alguna leyenda que debe incluir en
    el CFDI.Atributo condicional que indica el número de pesos
    mexicanos que equivalen a un dólar de Estados Unidos, de acuerdo
    al artículo 20 del Código Fiscal de la Federación.Atributo
    condicional que indica el importe total del comprobante en
    dólares de Estados Unidos."""
    subclass = None
    superclass = None
    def __init__(self, Version=None, MotivoTraslado=None, TipoOperacion=None, ClaveDePedimento=None, CertificadoOrigen=None, NumCertificadoOrigen=None, NumeroExportadorConfiable=None, Incoterm=None, Subdivision=None, Observaciones=None, TipoCambioUSD=None, TotalUSD=None, Emisor=None, Propietario=None, Receptor=None, Destinatario=None, Mercancias=None):
        self.original_tagname_ = None
        self.Version = _cast(None, Version)
        self.MotivoTraslado = _cast(None, MotivoTraslado)
        self.TipoOperacion = _cast(None, TipoOperacion)
        self.ClaveDePedimento = _cast(None, ClaveDePedimento)
        self.CertificadoOrigen = _cast(int, CertificadoOrigen)
        self.NumCertificadoOrigen = _cast(None, NumCertificadoOrigen)
        self.NumeroExportadorConfiable = _cast(None, NumeroExportadorConfiable)
        self.Incoterm = _cast(None, Incoterm)
        self.Subdivision = _cast(int, Subdivision)
        self.Observaciones = _cast(None, Observaciones)
        self.TipoCambioUSD = _cast(None, TipoCambioUSD)
        self.TotalUSD = _cast(None, TotalUSD)
        self.Emisor = Emisor
        if Propietario is None:
            self.Propietario = []
        else:
            self.Propietario = Propietario
        self.Receptor = Receptor
        if Destinatario is None:
            self.Destinatario = []
        else:
            self.Destinatario = Destinatario
        self.Mercancias = Mercancias
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComercioExterior)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComercioExterior.subclass:
            return ComercioExterior.subclass(*args_, **kwargs_)
        else:
            return ComercioExterior(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Emisor(self): return self.Emisor
    def set_Emisor(self, Emisor): self.Emisor = Emisor
    def get_Propietario(self): return self.Propietario
    def set_Propietario(self, Propietario): self.Propietario = Propietario
    def add_Propietario(self, value): self.Propietario.append(value)
    def insert_Propietario_at(self, index, value): self.Propietario.insert(index, value)
    def replace_Propietario_at(self, index, value): self.Propietario[index] = value
    def get_Receptor(self): return self.Receptor
    def set_Receptor(self, Receptor): self.Receptor = Receptor
    def get_Destinatario(self): return self.Destinatario
    def set_Destinatario(self, Destinatario): self.Destinatario = Destinatario
    def add_Destinatario(self, value): self.Destinatario.append(value)
    def insert_Destinatario_at(self, index, value): self.Destinatario.insert(index, value)
    def replace_Destinatario_at(self, index, value): self.Destinatario[index] = value
    def get_Mercancias(self): return self.Mercancias
    def set_Mercancias(self, Mercancias): self.Mercancias = Mercancias
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_MotivoTraslado(self): return self.MotivoTraslado
    def set_MotivoTraslado(self, MotivoTraslado): self.MotivoTraslado = MotivoTraslado
    def get_TipoOperacion(self): return self.TipoOperacion
    def set_TipoOperacion(self, TipoOperacion): self.TipoOperacion = TipoOperacion
    def get_ClaveDePedimento(self): return self.ClaveDePedimento
    def set_ClaveDePedimento(self, ClaveDePedimento): self.ClaveDePedimento = ClaveDePedimento
    def get_CertificadoOrigen(self): return self.CertificadoOrigen
    def set_CertificadoOrigen(self, CertificadoOrigen): self.CertificadoOrigen = CertificadoOrigen
    def get_NumCertificadoOrigen(self): return self.NumCertificadoOrigen
    def set_NumCertificadoOrigen(self, NumCertificadoOrigen): self.NumCertificadoOrigen = NumCertificadoOrigen
    def get_NumeroExportadorConfiable(self): return self.NumeroExportadorConfiable
    def set_NumeroExportadorConfiable(self, NumeroExportadorConfiable): self.NumeroExportadorConfiable = NumeroExportadorConfiable
    def get_Incoterm(self): return self.Incoterm
    def set_Incoterm(self, Incoterm): self.Incoterm = Incoterm
    def get_Subdivision(self): return self.Subdivision
    def set_Subdivision(self, Subdivision): self.Subdivision = Subdivision
    def get_Observaciones(self): return self.Observaciones
    def set_Observaciones(self, Observaciones): self.Observaciones = Observaciones
    def get_TipoCambioUSD(self): return self.TipoCambioUSD
    def set_TipoCambioUSD(self, TipoCambioUSD): self.TipoCambioUSD = TipoCambioUSD
    def get_TotalUSD(self): return self.TotalUSD
    def set_TotalUSD(self, TotalUSD): self.TotalUSD = TotalUSD
    def hasContent_(self):
        if (
            self.Emisor is not None or
            self.Propietario or
            self.Receptor is not None or
            self.Destinatario or
            self.Mercancias is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cce11:', name_='ComercioExterior', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComercioExterior')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cce11:', name_='ComercioExterior', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cce11:', name_='ComercioExterior'):
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            outfile.write(' Version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Version), input_name='Version')), ))
        if self.MotivoTraslado is not None and 'MotivoTraslado' not in already_processed:
            already_processed.add('MotivoTraslado')
            outfile.write(' MotivoTraslado=%s' % (quote_attrib(self.MotivoTraslado), ))
        if self.TipoOperacion is not None and 'TipoOperacion' not in already_processed:
            already_processed.add('TipoOperacion')
            outfile.write(' TipoOperacion=%s' % (quote_attrib(self.TipoOperacion), ))
        if self.ClaveDePedimento is not None and 'ClaveDePedimento' not in already_processed:
            already_processed.add('ClaveDePedimento')
            outfile.write(' ClaveDePedimento=%s' % (quote_attrib(self.ClaveDePedimento), ))
        if self.CertificadoOrigen is not None and 'CertificadoOrigen' not in already_processed:
            already_processed.add('CertificadoOrigen')
            outfile.write(' CertificadoOrigen="%s"' % self.gds_format_integer(self.CertificadoOrigen, input_name='CertificadoOrigen'))
        if self.NumCertificadoOrigen is not None and 'NumCertificadoOrigen' not in already_processed:
            already_processed.add('NumCertificadoOrigen')
            outfile.write(' NumCertificadoOrigen=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumCertificadoOrigen), input_name='NumCertificadoOrigen')), ))
        if self.NumeroExportadorConfiable is not None and 'NumeroExportadorConfiable' not in already_processed:
            already_processed.add('NumeroExportadorConfiable')
            outfile.write(' NumeroExportadorConfiable=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumeroExportadorConfiable), input_name='NumeroExportadorConfiable')), ))
        if self.Incoterm is not None and 'Incoterm' not in already_processed:
            already_processed.add('Incoterm')
            outfile.write(' Incoterm=%s' % (quote_attrib(self.Incoterm), ))
        if self.Subdivision is not None and 'Subdivision' not in already_processed:
            already_processed.add('Subdivision')
            outfile.write(' Subdivision="%s"' % self.gds_format_integer(self.Subdivision, input_name='Subdivision'))
        if self.Observaciones is not None and 'Observaciones' not in already_processed:
            already_processed.add('Observaciones')
            outfile.write(' Observaciones=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Observaciones), input_name='Observaciones')), ))
        if self.TipoCambioUSD is not None and 'TipoCambioUSD' not in already_processed:
            already_processed.add('TipoCambioUSD')
            outfile.write(' TipoCambioUSD=%s' % (quote_attrib(self.TipoCambioUSD), ))
        if self.TotalUSD is not None and 'TotalUSD' not in already_processed:
            already_processed.add('TotalUSD')
            outfile.write(' TotalUSD=%s' % (quote_attrib(self.TotalUSD), ))
    def exportChildren(self, outfile, level, namespace_='cce11:', name_='ComercioExterior', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Emisor is not None:
            self.Emisor.export(outfile, level, namespace_, name_='Emisor', pretty_print=pretty_print)
        for Propietario_ in self.Propietario:
            Propietario_.export(outfile, level, namespace_, name_='Propietario', pretty_print=pretty_print)
        if self.Receptor is not None:
            self.Receptor.export(outfile, level, namespace_, name_='Receptor', pretty_print=pretty_print)
        for Destinatario_ in self.Destinatario:
            Destinatario_.export(outfile, level, namespace_, name_='Destinatario', pretty_print=pretty_print)
        if self.Mercancias is not None:
            self.Mercancias.export(outfile, level, namespace_, name_='Mercancias', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Version', node)
        if value is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            self.Version = value
        value = find_attr_value_('MotivoTraslado', node)
        if value is not None and 'MotivoTraslado' not in already_processed:
            already_processed.add('MotivoTraslado')
            self.MotivoTraslado = value
        value = find_attr_value_('TipoOperacion', node)
        if value is not None and 'TipoOperacion' not in already_processed:
            already_processed.add('TipoOperacion')
            self.TipoOperacion = value
        value = find_attr_value_('ClaveDePedimento', node)
        if value is not None and 'ClaveDePedimento' not in already_processed:
            already_processed.add('ClaveDePedimento')
            self.ClaveDePedimento = value
        value = find_attr_value_('CertificadoOrigen', node)
        if value is not None and 'CertificadoOrigen' not in already_processed:
            already_processed.add('CertificadoOrigen')
            try:
                self.CertificadoOrigen = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('NumCertificadoOrigen', node)
        if value is not None and 'NumCertificadoOrigen' not in already_processed:
            already_processed.add('NumCertificadoOrigen')
            self.NumCertificadoOrigen = value
        value = find_attr_value_('NumeroExportadorConfiable', node)
        if value is not None and 'NumeroExportadorConfiable' not in already_processed:
            already_processed.add('NumeroExportadorConfiable')
            self.NumeroExportadorConfiable = value
        value = find_attr_value_('Incoterm', node)
        if value is not None and 'Incoterm' not in already_processed:
            already_processed.add('Incoterm')
            self.Incoterm = value
        value = find_attr_value_('Subdivision', node)
        if value is not None and 'Subdivision' not in already_processed:
            already_processed.add('Subdivision')
            try:
                self.Subdivision = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('Observaciones', node)
        if value is not None and 'Observaciones' not in already_processed:
            already_processed.add('Observaciones')
            self.Observaciones = value
        value = find_attr_value_('TipoCambioUSD', node)
        if value is not None and 'TipoCambioUSD' not in already_processed:
            already_processed.add('TipoCambioUSD')
            self.TipoCambioUSD = value
        value = find_attr_value_('TotalUSD', node)
        if value is not None and 'TotalUSD' not in already_processed:
            already_processed.add('TotalUSD')
            self.TotalUSD = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Emisor':
            obj_ = EmisorType7.factory()
            obj_.build(child_)
            self.Emisor = obj_
            obj_.original_tagname_ = 'Emisor'
        elif nodeName_ == 'Propietario':
            obj_ = PropietarioType.factory()
            obj_.build(child_)
            self.Propietario.append(obj_)
            obj_.original_tagname_ = 'Propietario'
        elif nodeName_ == 'Receptor':
            obj_ = ReceptorType8.factory()
            obj_.build(child_)
            self.Receptor = obj_
            obj_.original_tagname_ = 'Receptor'
        elif nodeName_ == 'Destinatario':
            obj_ = DestinatarioType.factory()
            obj_.build(child_)
            self.Destinatario.append(obj_)
            obj_.original_tagname_ = 'Destinatario'
        elif nodeName_ == 'Mercancias':
            obj_ = MercanciasType.factory()
            obj_.build(child_)
            self.Mercancias = obj_
            obj_.original_tagname_ = 'Mercancias'
# end class ComercioExterior


class Pagos(GeneratedsSuper):
    """Complemento para el Comprobante Fiscal Digital por Internet (CFDI)
    para registrar información sobre la recepción de pagos. El
    emisor de este complemento para recepción de pagos debe ser
    quien las leyes le obligue a expedir comprobantes por los actos
    o actividades que realicen, por los ingresos que se perciban o
    por las retenciones de contribuciones que efectúen.Atributo
    requerido que indica la versión del complemento para recepción
    de pagos."""
    subclass = None
    superclass = None
    def __init__(self, Version='1.0', Pago=None):
        self.original_tagname_ = None
        self.Version = _cast(None, Version)
        if Pago is None:
            self.Pago = []
        else:
            self.Pago = Pago
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Pagos)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Pagos.subclass:
            return Pagos.subclass(*args_, **kwargs_)
        else:
            return Pagos(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Pago(self): return self.Pago
    def set_Pago(self, Pago): self.Pago = Pago
    def add_Pago(self, value): self.Pago.append(value)
    def insert_Pago_at(self, index, value): self.Pago.insert(index, value)
    def replace_Pago_at(self, index, value): self.Pago[index] = value
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def hasContent_(self):
        if (
            self.Pago
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pago10:', name_='Pagos', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Pagos')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pago10:', name_='Pagos', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pago10:', name_='Pagos'):
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            outfile.write(' Version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Version), input_name='Version')), ))
    def exportChildren(self, outfile, level, namespace_='pago10:', name_='Pagos', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Pago_ in self.Pago:
            Pago_.export(outfile, level, namespace_, name_='Pago', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Version', node)
        if value is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            self.Version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Pago':
            obj_ = PagoType.factory()
            obj_.build(child_)
            self.Pago.append(obj_)
            obj_.original_tagname_ = 'Pago'
# end class Pagos


class CfdiRelacionadosType(GeneratedsSuper):
    """Atributo requerido para indicar la clave de la relación que existe
    entre éste que se esta generando y el o los CFDI previos."""
    subclass = None
    superclass = None
    def __init__(self, TipoRelacion=None, CfdiRelacionado=None):
        self.original_tagname_ = None
        self.TipoRelacion = _cast(None, TipoRelacion)
        if CfdiRelacionado is None:
            self.CfdiRelacionado = []
        else:
            self.CfdiRelacionado = CfdiRelacionado
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CfdiRelacionadosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CfdiRelacionadosType.subclass:
            return CfdiRelacionadosType.subclass(*args_, **kwargs_)
        else:
            return CfdiRelacionadosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CfdiRelacionado(self): return self.CfdiRelacionado
    def set_CfdiRelacionado(self, CfdiRelacionado): self.CfdiRelacionado = CfdiRelacionado
    def add_CfdiRelacionado(self, value): self.CfdiRelacionado.append(value)
    def insert_CfdiRelacionado_at(self, index, value): self.CfdiRelacionado.insert(index, value)
    def replace_CfdiRelacionado_at(self, index, value): self.CfdiRelacionado[index] = value
    def get_TipoRelacion(self): return self.TipoRelacion
    def set_TipoRelacion(self, TipoRelacion): self.TipoRelacion = TipoRelacion
    def hasContent_(self):
        if (
            self.CfdiRelacionado
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='CfdiRelacionadosType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CfdiRelacionadosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='CfdiRelacionadosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='CfdiRelacionadosType'):
        if self.TipoRelacion is not None and 'TipoRelacion' not in already_processed:
            already_processed.add('TipoRelacion')
            outfile.write(' TipoRelacion=%s' % (quote_attrib(self.TipoRelacion), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='CfdiRelacionadosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CfdiRelacionado_ in self.CfdiRelacionado:
            CfdiRelacionado_.export(outfile, level, namespace_, name_='CfdiRelacionado', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TipoRelacion', node)
        if value is not None and 'TipoRelacion' not in already_processed:
            already_processed.add('TipoRelacion')
            self.TipoRelacion = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CfdiRelacionado':
            obj_ = CfdiRelacionadoType.factory()
            obj_.build(child_)
            self.CfdiRelacionado.append(obj_)
            obj_.original_tagname_ = 'CfdiRelacionado'
# end class CfdiRelacionadosType


class CfdiRelacionadoType(GeneratedsSuper):
    """Atributo opcional para registrar el folio fiscal (UUID) de un CFDI
    relacionado con el presente comprobante, por ejemplo: Si el CFDI
    relacionado es un comprobante de traslado que sirve para
    registrar el movimiento de la mercancía. Si este comprobante se
    usa como nota de crédito o nota de débito del comprobante
    relacionado. Si este comprobante es una devolución sobre el
    comprobante relacionado. Si éste sustituye a una factura
    cancelada."""
    subclass = None
    superclass = None
    def __init__(self, UUID=None):
        self.original_tagname_ = None
        self.UUID = _cast(None, UUID)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CfdiRelacionadoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CfdiRelacionadoType.subclass:
            return CfdiRelacionadoType.subclass(*args_, **kwargs_)
        else:
            return CfdiRelacionadoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UUID(self): return self.UUID
    def set_UUID(self, UUID): self.UUID = UUID
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='CfdiRelacionadoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CfdiRelacionadoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='CfdiRelacionadoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='CfdiRelacionadoType'):
        if self.UUID is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            outfile.write(' UUID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UUID), input_name='UUID')), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='CfdiRelacionadoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('UUID', node)
        if value is not None and 'UUID' not in already_processed:
            already_processed.add('UUID')
            self.UUID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CfdiRelacionadoType


class EmisorType(GeneratedsSuper):
    """Atributo requerido para registrar la Clave del Registro Federal de
    Contribuyentes correspondiente al contribuyente emisor del
    comprobante.Atributo opcional para registrar el nombre,
    denominación o razón social del contribuyente emisor del
    comprobante.Atributo requerido para incorporar la clave del
    régimen del contribuyente emisor al que aplicará el efecto
    fiscal de este comprobante."""
    subclass = None
    superclass = None
    def __init__(self, Rfc=None, Nombre=None, RegimenFiscal=None):
        self.original_tagname_ = None
        self.Rfc = _cast(None, Rfc)
        self.Nombre = _cast(None, Nombre)
        self.RegimenFiscal = _cast(None, RegimenFiscal)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmisorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmisorType.subclass:
            return EmisorType.subclass(*args_, **kwargs_)
        else:
            return EmisorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Rfc(self): return self.Rfc
    def set_Rfc(self, Rfc): self.Rfc = Rfc
    def get_Nombre(self): return self.Nombre
    def set_Nombre(self, Nombre): self.Nombre = Nombre
    def get_RegimenFiscal(self): return self.RegimenFiscal
    def set_RegimenFiscal(self, RegimenFiscal): self.RegimenFiscal = RegimenFiscal
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='EmisorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmisorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='EmisorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='EmisorType'):
        if self.Rfc is not None and 'Rfc' not in already_processed:
            already_processed.add('Rfc')
            outfile.write(' Rfc=%s' % (quote_attrib(self.Rfc), ))
        if self.Nombre is not None and 'Nombre' not in already_processed:
            already_processed.add('Nombre')
            outfile.write(' Nombre=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Nombre), input_name='Nombre')), ))
        if self.RegimenFiscal is not None and 'RegimenFiscal' not in already_processed:
            already_processed.add('RegimenFiscal')
            outfile.write(' RegimenFiscal=%s' % (quote_attrib(self.RegimenFiscal), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='EmisorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Rfc', node)
        if value is not None and 'Rfc' not in already_processed:
            already_processed.add('Rfc')
            self.Rfc = value
        value = find_attr_value_('Nombre', node)
        if value is not None and 'Nombre' not in already_processed:
            already_processed.add('Nombre')
            self.Nombre = value
        value = find_attr_value_('RegimenFiscal', node)
        if value is not None and 'RegimenFiscal' not in already_processed:
            already_processed.add('RegimenFiscal')
            self.RegimenFiscal = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EmisorType


class ReceptorType(GeneratedsSuper):
    """Atributo requerido para precisar la Clave del Registro Federal de
    Contribuyentes correspondiente al contribuyente receptor del
    comprobante.Atributo opcional para precisar el nombre,
    denominación o razón social del contribuyente receptor del
    comprobante.Atributo condicional para registrar la clave del
    país de residencia para efectos fiscales del receptor del
    comprobante, cuando se trate de un extranjero, y que es conforme
    con la especificación ISO 3166-1 alpha-3. Es requerido cuando se
    incluya el complemento de comercio exterior o se registre el
    atributo NumRegIdTrib.Atributo condicional para expresar el
    número de registro de identidad fiscal del receptor cuando sea
    residente en el extranjero. Es requerido cuando se incluya el
    complemento de comercio exterior.Atributo requerido para
    expresar la clave del uso que dará a esta factura el receptor
    del CFDI."""
    subclass = None
    superclass = None
    def __init__(self, Rfc=None, Nombre=None, ResidenciaFiscal=None, NumRegIdTrib=None, UsoCFDI=None):
        self.original_tagname_ = None
        self.Rfc = _cast(None, Rfc)
        self.Nombre = _cast(None, Nombre)
        self.ResidenciaFiscal = _cast(None, ResidenciaFiscal)
        self.NumRegIdTrib = _cast(None, NumRegIdTrib)
        self.UsoCFDI = _cast(None, UsoCFDI)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReceptorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReceptorType.subclass:
            return ReceptorType.subclass(*args_, **kwargs_)
        else:
            return ReceptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Rfc(self): return self.Rfc
    def set_Rfc(self, Rfc): self.Rfc = Rfc
    def get_Nombre(self): return self.Nombre
    def set_Nombre(self, Nombre): self.Nombre = Nombre
    def get_ResidenciaFiscal(self): return self.ResidenciaFiscal
    def set_ResidenciaFiscal(self, ResidenciaFiscal): self.ResidenciaFiscal = ResidenciaFiscal
    def get_NumRegIdTrib(self): return self.NumRegIdTrib
    def set_NumRegIdTrib(self, NumRegIdTrib): self.NumRegIdTrib = NumRegIdTrib
    def get_UsoCFDI(self): return self.UsoCFDI
    def set_UsoCFDI(self, UsoCFDI): self.UsoCFDI = UsoCFDI
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='ReceptorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReceptorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='ReceptorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='ReceptorType'):
        if self.Rfc is not None and 'Rfc' not in already_processed:
            already_processed.add('Rfc')
            outfile.write(' Rfc=%s' % (quote_attrib(self.Rfc), ))
        if self.Nombre is not None and 'Nombre' not in already_processed:
            already_processed.add('Nombre')
            outfile.write(' Nombre=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Nombre), input_name='Nombre')), ))
        if self.ResidenciaFiscal is not None and 'ResidenciaFiscal' not in already_processed:
            already_processed.add('ResidenciaFiscal')
            outfile.write(' ResidenciaFiscal=%s' % (quote_attrib(self.ResidenciaFiscal), ))
        if self.NumRegIdTrib is not None and 'NumRegIdTrib' not in already_processed:
            already_processed.add('NumRegIdTrib')
            outfile.write(' NumRegIdTrib=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumRegIdTrib), input_name='NumRegIdTrib')), ))
        if self.UsoCFDI is not None and 'UsoCFDI' not in already_processed:
            already_processed.add('UsoCFDI')
            outfile.write(' UsoCFDI=%s' % (quote_attrib(self.UsoCFDI), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='ReceptorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Rfc', node)
        if value is not None and 'Rfc' not in already_processed:
            already_processed.add('Rfc')
            self.Rfc = value
        value = find_attr_value_('Nombre', node)
        if value is not None and 'Nombre' not in already_processed:
            already_processed.add('Nombre')
            self.Nombre = value
        value = find_attr_value_('ResidenciaFiscal', node)
        if value is not None and 'ResidenciaFiscal' not in already_processed:
            already_processed.add('ResidenciaFiscal')
            self.ResidenciaFiscal = value
        value = find_attr_value_('NumRegIdTrib', node)
        if value is not None and 'NumRegIdTrib' not in already_processed:
            already_processed.add('NumRegIdTrib')
            self.NumRegIdTrib = value
        value = find_attr_value_('UsoCFDI', node)
        if value is not None and 'UsoCFDI' not in already_processed:
            already_processed.add('UsoCFDI')
            self.UsoCFDI = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReceptorType


class ConceptosType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Concepto=None):
        self.original_tagname_ = None
        if Concepto is None:
            self.Concepto = []
        else:
            self.Concepto = Concepto
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptosType.subclass:
            return ConceptosType.subclass(*args_, **kwargs_)
        else:
            return ConceptosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Concepto(self): return self.Concepto
    def set_Concepto(self, Concepto): self.Concepto = Concepto
    def add_Concepto(self, value): self.Concepto.append(value)
    def insert_Concepto_at(self, index, value): self.Concepto.insert(index, value)
    def replace_Concepto_at(self, index, value): self.Concepto[index] = value
    def hasContent_(self):
        if (
            self.Concepto
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='ConceptosType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConceptosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='ConceptosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='ConceptosType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='ConceptosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Concepto_ in self.Concepto:
            Concepto_.export(outfile, level, namespace_, name_='Concepto', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Concepto':
            obj_ = ConceptoType.factory()
            obj_.build(child_)
            self.Concepto.append(obj_)
            obj_.original_tagname_ = 'Concepto'
# end class ConceptosType


class ConceptoType(GeneratedsSuper):
    """Atributo requerido para expresar la clave del producto o del
    servicio amparado por el presente concepto. Es requerido y deben
    utilizar las claves del catálogo de productos y servicios,
    cuando los conceptos que registren por sus actividades
    correspondan con dichos conceptos.Atributo opcional para
    expresar el número de parte, identificador del producto o del
    servicio, la clave de producto o servicio, SKU o equivalente,
    propia de la operación del emisor, amparado por el presente
    concepto. Opcionalmente se puede utilizar claves del estándar
    GTIN.Atributo requerido para precisar la cantidad de bienes o
    servicios del tipo particular definido por el presente
    concepto.Atributo requerido para precisar la clave de unidad de
    medida estandarizada aplicable para la cantidad expresada en el
    concepto. La unidad debe corresponder con la descripción del
    concepto.Atributo opcional para precisar la unidad de medida
    propia de la operación del emisor, aplicable para la cantidad
    expresada en el concepto. La unidad debe corresponder con la
    descripción del concepto.Atributo requerido para precisar la
    descripción del bien o servicio cubierto por el presente
    concepto.Atributo requerido para precisar el valor o precio
    unitario del bien o servicio cubierto por el presente
    concepto.Atributo requerido para precisar el importe total de
    los bienes o servicios del presente concepto. Debe ser
    equivalente al resultado de multiplicar la cantidad por el valor
    unitario expresado en el concepto. No se permiten valores
    negativos. Atributo opcional para representar el importe de los
    descuentos aplicables al concepto. No se permiten valores
    negativos."""
    subclass = None
    superclass = None
    def __init__(self, ClaveProdServ=None, NoIdentificacion=None, Cantidad=None, ClaveUnidad=None, Unidad=None, Descripcion=None, ValorUnitario=None, Importe=None, Descuento=None, Impuestos=None, InformacionAduanera=None, CuentaPredial=None, ComplementoConcepto=None, Parte=None):
        self.original_tagname_ = None
        self.ClaveProdServ = _cast(None, ClaveProdServ)
        self.NoIdentificacion = _cast(None, NoIdentificacion)
        #self.Cantidad = _cast(float, Cantidad)
        self.Cantidad = _cast(None, Cantidad)
        self.ClaveUnidad = _cast(None, ClaveUnidad)
        self.Unidad = _cast(None, Unidad)
        if isinstance(Descripcion, str):
            Descripcion = Descripcion.decode('utf8')
        self.Descripcion = _cast(None, Descripcion)
        self.ValorUnitario = _cast(None, ValorUnitario)
        self.Importe = _cast(None, Importe)
        self.Descuento = _cast(None, Descuento)
        self.Impuestos = Impuestos
        if InformacionAduanera is None:
            self.InformacionAduanera = []
        else:
            self.InformacionAduanera = InformacionAduanera
        self.CuentaPredial = CuentaPredial
        self.ComplementoConcepto = ComplementoConcepto
        if Parte is None:
            self.Parte = []
        else:
            self.Parte = Parte
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConceptoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConceptoType.subclass:
            return ConceptoType.subclass(*args_, **kwargs_)
        else:
            return ConceptoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Impuestos(self): return self.Impuestos
    def set_Impuestos(self, Impuestos): self.Impuestos = Impuestos
    def get_InformacionAduanera(self): return self.InformacionAduanera
    def set_InformacionAduanera(self, InformacionAduanera): self.InformacionAduanera = InformacionAduanera
    def add_InformacionAduanera(self, value): self.InformacionAduanera.append(value)
    def insert_InformacionAduanera_at(self, index, value): self.InformacionAduanera.insert(index, value)
    def replace_InformacionAduanera_at(self, index, value): self.InformacionAduanera[index] = value
    def get_CuentaPredial(self): return self.CuentaPredial
    def set_CuentaPredial(self, CuentaPredial): self.CuentaPredial = CuentaPredial
    def get_ComplementoConcepto(self): return self.ComplementoConcepto
    def set_ComplementoConcepto(self, ComplementoConcepto): self.ComplementoConcepto = ComplementoConcepto
    def get_Parte(self): return self.Parte
    def set_Parte(self, Parte): self.Parte = Parte
    def add_Parte(self, value): self.Parte.append(value)
    def insert_Parte_at(self, index, value): self.Parte.insert(index, value)
    def replace_Parte_at(self, index, value): self.Parte[index] = value
    def get_ClaveProdServ(self): return self.ClaveProdServ
    def set_ClaveProdServ(self, ClaveProdServ): self.ClaveProdServ = ClaveProdServ
    def get_NoIdentificacion(self): return self.NoIdentificacion
    def set_NoIdentificacion(self, NoIdentificacion): self.NoIdentificacion = NoIdentificacion
    def get_Cantidad(self): return self.Cantidad
    def set_Cantidad(self, Cantidad): self.Cantidad = Cantidad
    def get_ClaveUnidad(self): return self.ClaveUnidad
    def set_ClaveUnidad(self, ClaveUnidad): self.ClaveUnidad = ClaveUnidad
    def get_Unidad(self): return self.Unidad
    def set_Unidad(self, Unidad): self.Unidad = Unidad
    def get_Descripcion(self): return self.Descripcion
    def set_Descripcion(self, Descripcion): self.Descripcion = Descripcion
    def get_ValorUnitario(self): return self.ValorUnitario
    def set_ValorUnitario(self, ValorUnitario): self.ValorUnitario = ValorUnitario
    def get_Importe(self): return self.Importe
    def set_Importe(self, Importe): self.Importe = Importe
    def get_Descuento(self): return self.Descuento
    def set_Descuento(self, Descuento): self.Descuento = Descuento
    def hasContent_(self):
        if (
            self.Impuestos is not None or
            self.InformacionAduanera or
            self.CuentaPredial is not None or
            self.ComplementoConcepto is not None or
            self.Parte
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='ConceptoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConceptoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='ConceptoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='ConceptoType'):
        if self.ClaveProdServ is not None and 'ClaveProdServ' not in already_processed:
            already_processed.add('ClaveProdServ')
            outfile.write(' ClaveProdServ=%s' % (quote_attrib(self.ClaveProdServ), ))
        if self.NoIdentificacion is not None and 'NoIdentificacion' not in already_processed:
            already_processed.add('NoIdentificacion')
            outfile.write(' NoIdentificacion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NoIdentificacion), input_name='NoIdentificacion')), ))
        if self.Cantidad is not None and 'Cantidad' not in already_processed:
            already_processed.add('Cantidad')
            #outfile.write(' Cantidad="%s"' % self.gds_format_float(self.Cantidad, input_name='Cantidad'))
            outfile.write(' Cantidad="%s"' % self.Cantidad)
        if self.ClaveUnidad is not None and 'ClaveUnidad' not in already_processed:
            already_processed.add('ClaveUnidad')
            outfile.write(' ClaveUnidad=%s' % (quote_attrib(self.ClaveUnidad), ))
        if self.Unidad is not None and 'Unidad' not in already_processed:
            already_processed.add('Unidad')
            outfile.write(' Unidad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Unidad), input_name='Unidad')), ))
        if self.Descripcion is not None and 'Descripcion' not in already_processed:
            already_processed.add('Descripcion')
            outfile.write(' Descripcion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Descripcion), input_name='Descripcion')), ))
        if self.ValorUnitario is not None and 'ValorUnitario' not in already_processed:
            already_processed.add('ValorUnitario')
            outfile.write(' ValorUnitario=%s' % (quote_attrib(self.ValorUnitario), ))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe=%s' % (quote_attrib(self.Importe), ))
        if self.Descuento is not None and 'Descuento' not in already_processed:
            already_processed.add('Descuento')
            outfile.write(' Descuento=%s' % (quote_attrib(self.Descuento), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='ConceptoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Impuestos is not None:
            self.Impuestos.export(outfile, level, namespace_, name_='Impuestos', pretty_print=pretty_print)
        for InformacionAduanera_ in self.InformacionAduanera:
            InformacionAduanera_.export(outfile, level, namespace_, name_='InformacionAduanera', pretty_print=pretty_print)
        if self.CuentaPredial is not None:
            self.CuentaPredial.export(outfile, level, namespace_, name_='CuentaPredial', pretty_print=pretty_print)
        if self.ComplementoConcepto is not None:
            self.ComplementoConcepto.export(outfile, level, namespace_, name_='ComplementoConcepto', pretty_print=pretty_print)
        for Parte_ in self.Parte:
            Parte_.export(outfile, level, namespace_, name_='Parte', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ClaveProdServ', node)
        if value is not None and 'ClaveProdServ' not in already_processed:
            already_processed.add('ClaveProdServ')
            self.ClaveProdServ = value
        value = find_attr_value_('NoIdentificacion', node)
        if value is not None and 'NoIdentificacion' not in already_processed:
            already_processed.add('NoIdentificacion')
            self.NoIdentificacion = value
        value = find_attr_value_('Cantidad', node)
        if value is not None and 'Cantidad' not in already_processed:
            already_processed.add('Cantidad')
            try:
                self.Cantidad = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Cantidad): %s' % exp)
        value = find_attr_value_('ClaveUnidad', node)
        if value is not None and 'ClaveUnidad' not in already_processed:
            already_processed.add('ClaveUnidad')
            self.ClaveUnidad = value
        value = find_attr_value_('Unidad', node)
        if value is not None and 'Unidad' not in already_processed:
            already_processed.add('Unidad')
            self.Unidad = value
        value = find_attr_value_('Descripcion', node)
        if value is not None and 'Descripcion' not in already_processed:
            already_processed.add('Descripcion')
            self.Descripcion = value
        value = find_attr_value_('ValorUnitario', node)
        if value is not None and 'ValorUnitario' not in already_processed:
            already_processed.add('ValorUnitario')
            self.ValorUnitario = value
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            self.Importe = value
        value = find_attr_value_('Descuento', node)
        if value is not None and 'Descuento' not in already_processed:
            already_processed.add('Descuento')
            self.Descuento = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Impuestos':
            obj_ = ImpuestosType.factory()
            obj_.build(child_)
            self.Impuestos = obj_
            obj_.original_tagname_ = 'Impuestos'
        elif nodeName_ == 'InformacionAduanera':
            obj_ = InformacionAduaneraType.factory()
            obj_.build(child_)
            self.InformacionAduanera.append(obj_)
            obj_.original_tagname_ = 'InformacionAduanera'
        elif nodeName_ == 'CuentaPredial':
            obj_ = CuentaPredialType.factory()
            obj_.build(child_)
            self.CuentaPredial = obj_
            obj_.original_tagname_ = 'CuentaPredial'
        elif nodeName_ == 'ComplementoConcepto':
            obj_ = ComplementoConceptoType.factory()
            obj_.build(child_)
            self.ComplementoConcepto = obj_
            obj_.original_tagname_ = 'ComplementoConcepto'
        elif nodeName_ == 'Parte':
            obj_ = ParteType.factory()
            obj_.build(child_)
            self.Parte.append(obj_)
            obj_.original_tagname_ = 'Parte'
# end class ConceptoType


class ImpuestosType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Traslados=None, Retenciones=None):
        self.original_tagname_ = None
        self.Traslados = Traslados
        self.Retenciones = Retenciones
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImpuestosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImpuestosType.subclass:
            return ImpuestosType.subclass(*args_, **kwargs_)
        else:
            return ImpuestosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Traslados(self): return self.Traslados
    def set_Traslados(self, Traslados): self.Traslados = Traslados
    def get_Retenciones(self): return self.Retenciones
    def set_Retenciones(self, Retenciones): self.Retenciones = Retenciones
    def hasContent_(self):
        if (
            self.Traslados is not None or
            self.Retenciones is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='ImpuestosType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImpuestosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='ImpuestosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='ImpuestosType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='ImpuestosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Traslados is not None:
            self.Traslados.export(outfile, level, namespace_, name_='Traslados', pretty_print=pretty_print)
        if self.Retenciones is not None:
            self.Retenciones.export(outfile, level, namespace_, name_='Retenciones', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Traslados':
            obj_ = TrasladosType.factory()
            obj_.build(child_)
            self.Traslados = obj_
            obj_.original_tagname_ = 'Traslados'
        elif nodeName_ == 'Retenciones':
            obj_ = RetencionesType.factory()
            obj_.build(child_)
            self.Retenciones = obj_
            obj_.original_tagname_ = 'Retenciones'
# end class ImpuestosType


class TrasladosType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Traslado=None):
        self.original_tagname_ = None
        if Traslado is None:
            self.Traslado = []
        else:
            self.Traslado = Traslado
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrasladosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrasladosType.subclass:
            return TrasladosType.subclass(*args_, **kwargs_)
        else:
            return TrasladosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Traslado(self): return self.Traslado
    def set_Traslado(self, Traslado): self.Traslado = Traslado
    def add_Traslado(self, value): self.Traslado.append(value)
    def insert_Traslado_at(self, index, value): self.Traslado.insert(index, value)
    def replace_Traslado_at(self, index, value): self.Traslado[index] = value
    def hasContent_(self):
        if (
            self.Traslado
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='TrasladosType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrasladosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='TrasladosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='TrasladosType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='TrasladosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Traslado_ in self.Traslado:
            Traslado_.export(outfile, level, namespace_, name_='Traslado', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Traslado':
            obj_ = TrasladoType.factory()
            obj_.build(child_)
            self.Traslado.append(obj_)
            obj_.original_tagname_ = 'Traslado'
# end class TrasladosType


class TrasladoType(GeneratedsSuper):
    """Atributo requerido para señalar la base para el cálculo del
    impuesto, la determinación de la base se realiza de acuerdo con
    las disposiciones fiscales vigentes. No se permiten valores
    negativos.Atributo requerido para señalar la clave del tipo de
    impuesto trasladado aplicable al concepto.Atributo requerido
    para señalar la clave del tipo de factor que se aplica a la base
    del impuesto.Atributo condicional para señalar el valor de la
    tasa o cuota del impuesto que se traslada para el presente
    concepto. Es requerido cuando el atributo TipoFactor tenga un
    valor que corresponda a Tasa o Cuota.Atributo condicional para
    señalar el importe del impuesto trasladado que aplica al
    concepto. No se permiten valores negativos. Es requerido cuando
    TipoFactor sea Tasa o Cuota"""
    subclass = None
    superclass = None
    def __init__(self, Base=None, Impuesto=None, TipoFactor=None, TasaOCuota=None, Importe=None):
        self.original_tagname_ = None
        self.Base = _cast(None, Base)
        self.Impuesto = _cast(None, Impuesto)
        self.TipoFactor = _cast(None, TipoFactor)
        self.TasaOCuota = _cast(None, TasaOCuota)
        self.Importe = _cast(None, Importe)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrasladoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrasladoType.subclass:
            return TrasladoType.subclass(*args_, **kwargs_)
        else:
            return TrasladoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Base(self): return self.Base
    def set_Base(self, Base): self.Base = Base
    def get_Impuesto(self): return self.Impuesto
    def set_Impuesto(self, Impuesto): self.Impuesto = Impuesto
    def get_TipoFactor(self): return self.TipoFactor
    def set_TipoFactor(self, TipoFactor): self.TipoFactor = TipoFactor
    def get_TasaOCuota(self): return self.TasaOCuota
    def set_TasaOCuota(self, TasaOCuota): self.TasaOCuota = TasaOCuota
    def get_Importe(self): return self.Importe
    def set_Importe(self, Importe): self.Importe = Importe
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='TrasladoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrasladoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='TrasladoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='TrasladoType'):
        if self.Base is not None and 'Base' not in already_processed:
            already_processed.add('Base')
            outfile.write(' Base=%s' % (quote_attrib(self.Base), ))
        if self.Impuesto is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            outfile.write(' Impuesto=%s' % (quote_attrib(self.Impuesto), ))
        if self.TipoFactor is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            outfile.write(' TipoFactor=%s' % (quote_attrib(self.TipoFactor), ))
        if self.TasaOCuota is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            outfile.write(' TasaOCuota=%s' % (quote_attrib(self.TasaOCuota), ))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe=%s' % (quote_attrib(self.Importe), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='TrasladoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Base', node)
        if value is not None and 'Base' not in already_processed:
            already_processed.add('Base')
            self.Base = value
        value = find_attr_value_('Impuesto', node)
        if value is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            self.Impuesto = value
        value = find_attr_value_('TipoFactor', node)
        if value is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            self.TipoFactor = value
        value = find_attr_value_('TasaOCuota', node)
        if value is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            self.TasaOCuota = value
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            self.Importe = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TrasladoType


class RetencionesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Retencion=None):
        self.original_tagname_ = None
        if Retencion is None:
            self.Retencion = []
        else:
            self.Retencion = Retencion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetencionesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetencionesType.subclass:
            return RetencionesType.subclass(*args_, **kwargs_)
        else:
            return RetencionesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Retencion(self): return self.Retencion
    def set_Retencion(self, Retencion): self.Retencion = Retencion
    def add_Retencion(self, value): self.Retencion.append(value)
    def insert_Retencion_at(self, index, value): self.Retencion.insert(index, value)
    def replace_Retencion_at(self, index, value): self.Retencion[index] = value
    def hasContent_(self):
        if (
            self.Retencion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='RetencionesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RetencionesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='RetencionesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='RetencionesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='RetencionesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Retencion_ in self.Retencion:
            Retencion_.export(outfile, level, namespace_, name_='Retencion', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Retencion':
            obj_ = RetencionType.factory()
            obj_.build(child_)
            self.Retencion.append(obj_)
            obj_.original_tagname_ = 'Retencion'
# end class RetencionesType


class RetencionType(GeneratedsSuper):
    """Atributo requerido para señalar la base para el cálculo de la
    retención, la determinación de la base se realiza de acuerdo con
    las disposiciones fiscales vigentes. No se permiten valores
    negativos.Atributo requerido para señalar la clave del tipo de
    impuesto retenido aplicable al concepto.Atributo requerido para
    señalar la clave del tipo de factor que se aplica a la base del
    impuesto.Atributo requerido para señalar la tasa o cuota del
    impuesto que se retiene para el presente concepto.Atributo
    requerido para señalar el importe del impuesto retenido que
    aplica al concepto. No se permiten valores negativos."""
    subclass = None
    superclass = None
    def __init__(self, Base=None, Impuesto=None, TipoFactor=None, TasaOCuota=None, Importe=None):
        self.original_tagname_ = None
        self.Base = _cast(None, Base)
        self.Impuesto = _cast(None, Impuesto)
        self.TipoFactor = _cast(None, TipoFactor)
        self.TasaOCuota = _cast(None, TasaOCuota)
        self.Importe = _cast(None, Importe)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetencionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetencionType.subclass:
            return RetencionType.subclass(*args_, **kwargs_)
        else:
            return RetencionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Base(self): return self.Base
    def set_Base(self, Base): self.Base = Base
    def get_Impuesto(self): return self.Impuesto
    def set_Impuesto(self, Impuesto): self.Impuesto = Impuesto
    def get_TipoFactor(self): return self.TipoFactor
    def set_TipoFactor(self, TipoFactor): self.TipoFactor = TipoFactor
    def get_TasaOCuota(self): return self.TasaOCuota
    def set_TasaOCuota(self, TasaOCuota): self.TasaOCuota = TasaOCuota
    def get_Importe(self): return self.Importe
    def set_Importe(self, Importe): self.Importe = Importe
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='RetencionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RetencionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='RetencionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='RetencionType'):
        if self.Base is not None and 'Base' not in already_processed:
            already_processed.add('Base')
            outfile.write(' Base=%s' % (quote_attrib(self.Base), ))
        if self.Impuesto is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            outfile.write(' Impuesto=%s' % (quote_attrib(self.Impuesto), ))
        if self.TipoFactor is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            outfile.write(' TipoFactor=%s' % (quote_attrib(self.TipoFactor), ))
        if self.TasaOCuota is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            #outfile.write(' TasaOCuota="%s"' % self.gds_format_float(self.TasaOCuota, input_name='TasaOCuota'))
            outfile.write(' TasaOCuota="%s"' % self.TasaOCuota,)
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe=%s' % (quote_attrib(self.Importe), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='RetencionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Base', node)
        if value is not None and 'Base' not in already_processed:
            already_processed.add('Base')
            self.Base = value
        value = find_attr_value_('Impuesto', node)
        if value is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            self.Impuesto = value
        value = find_attr_value_('TipoFactor', node)
        if value is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            self.TipoFactor = value
        value = find_attr_value_('TasaOCuota', node)
        if value is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            try:
                self.TasaOCuota = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (TasaOCuota): %s' % exp)
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            self.Importe = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RetencionType


class InformacionAduaneraType(GeneratedsSuper):
    """Atributo requerido para expresar el número del pedimento que ampara
    la importación del bien que se expresa en el siguiente formato:
    últimos 2 dígitos del año de validación seguidos por dos
    espacios, 2 dígitos de la aduana de despacho seguidos por dos
    espacios, 4 dígitos del número de la patente seguidos por dos
    espacios, 1 dígito que corresponde al último dígito del año en
    curso, salvo que se trate de un pedimento consolidado iniciado
    en el año inmediato anterior o del pedimento original de una
    rectificación, seguido de 6 dígitos de la numeración progresiva
    por aduana."""
    subclass = None
    superclass = None
    def __init__(self, NumeroPedimento=None):
        self.original_tagname_ = None
        self.NumeroPedimento = _cast(None, NumeroPedimento)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformacionAduaneraType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformacionAduaneraType.subclass:
            return InformacionAduaneraType.subclass(*args_, **kwargs_)
        else:
            return InformacionAduaneraType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumeroPedimento(self): return self.NumeroPedimento
    def set_NumeroPedimento(self, NumeroPedimento): self.NumeroPedimento = NumeroPedimento
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='InformacionAduaneraType', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InformacionAduaneraType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='InformacionAduaneraType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='InformacionAduaneraType'):
        if self.NumeroPedimento is not None and 'NumeroPedimento' not in already_processed:
            already_processed.add('NumeroPedimento')
            outfile.write(' NumeroPedimento=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumeroPedimento), input_name='NumeroPedimento')), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='InformacionAduaneraType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NumeroPedimento', node)
        if value is not None and 'NumeroPedimento' not in already_processed:
            already_processed.add('NumeroPedimento')
            self.NumeroPedimento = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InformacionAduaneraType


class CuentaPredialType(GeneratedsSuper):
    """Atributo requerido para precisar el número de la cuenta predial del
    inmueble cubierto por el presente concepto, o bien para
    incorporar los datos de identificación del certificado de
    participación inmobiliaria no amortizable, tratándose de
    arrendamiento."""
    subclass = None
    superclass = None
    def __init__(self, Numero=None):
        self.original_tagname_ = None
        self.Numero = _cast(None, Numero)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CuentaPredialType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CuentaPredialType.subclass:
            return CuentaPredialType.subclass(*args_, **kwargs_)
        else:
            return CuentaPredialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Numero(self): return self.Numero
    def set_Numero(self, Numero): self.Numero = Numero
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='CuentaPredialType', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CuentaPredialType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='CuentaPredialType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='CuentaPredialType'):
        if self.Numero is not None and 'Numero' not in already_processed:
            already_processed.add('Numero')
            #outfile.write(' Numero=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Numero), input_name='Numero')), ))
            outfile.write(' Numero=%s' % quote_attrib(self.Numero))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='CuentaPredialType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Numero', node)
        if value is not None and 'Numero' not in already_processed:
            already_processed.add('Numero')
            self.Numero = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CuentaPredialType


class ComplementoConceptoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComplementoConceptoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComplementoConceptoType.subclass:
            return ComplementoConceptoType.subclass(*args_, **kwargs_)
        else:
            return ComplementoConceptoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='ComplementoConceptoType', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComplementoConceptoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='iedu:', name_='ComplementoConceptoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='ComplementoConceptoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='iedu:', name_='ComplementoConceptoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'ComplementoConceptoType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class ComplementoConceptoType


class ParteType(GeneratedsSuper):
    """Atributo requerido para expresar la clave del producto o del
    servicio amparado por la presente parte. Es requerido y deben
    utilizar las claves del catálogo de productos y servicios,
    cuando los conceptos que registren por sus actividades
    correspondan con dichos conceptos.Atributo opcional para
    expresar el número de serie, número de parte del bien o
    identificador del producto o del servicio amparado por la
    presente parte. Opcionalmente se puede utilizar claves del
    estándar GTIN.Atributo requerido para precisar la cantidad de
    bienes o servicios del tipo particular definido por la presente
    parte.Atributo opcional para precisar la unidad de medida propia
    de la operación del emisor, aplicable para la cantidad expresada
    en la parte. La unidad debe corresponder con la descripción de
    la parte.Atributo requerido para precisar la descripción del
    bien o servicio cubierto por la presente parte.Atributo opcional
    para precisar el valor o precio unitario del bien o servicio
    cubierto por la presente parte. No se permiten valores
    negativos.Atributo opcional para precisar el importe total de
    los bienes o servicios de la presente parte. Debe ser
    equivalente al resultado de multiplicar la cantidad por el valor
    unitario expresado en la parte. No se permiten valores
    negativos."""
    subclass = None
    superclass = None
    def __init__(self, ClaveProdServ=None, NoIdentificacion=None, Cantidad=None, Unidad=None, Descripcion=None, ValorUnitario=None, Importe=None, InformacionAduanera=None):
        self.original_tagname_ = None
        self.ClaveProdServ = _cast(None, ClaveProdServ)
        self.NoIdentificacion = _cast(None, NoIdentificacion)
        self.Cantidad = _cast(float, Cantidad)
        self.Unidad = _cast(None, Unidad)
        self.Descripcion = _cast(None, Descripcion)
        self.ValorUnitario = _cast(None, ValorUnitario)
        self.Importe = _cast(None, Importe)
        if InformacionAduanera is None:
            self.InformacionAduanera = []
        else:
            self.InformacionAduanera = InformacionAduanera
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ParteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ParteType.subclass:
            return ParteType.subclass(*args_, **kwargs_)
        else:
            return ParteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InformacionAduanera(self): return self.InformacionAduanera
    def set_InformacionAduanera(self, InformacionAduanera): self.InformacionAduanera = InformacionAduanera
    def add_InformacionAduanera(self, value): self.InformacionAduanera.append(value)
    def insert_InformacionAduanera_at(self, index, value): self.InformacionAduanera.insert(index, value)
    def replace_InformacionAduanera_at(self, index, value): self.InformacionAduanera[index] = value
    def get_ClaveProdServ(self): return self.ClaveProdServ
    def set_ClaveProdServ(self, ClaveProdServ): self.ClaveProdServ = ClaveProdServ
    def get_NoIdentificacion(self): return self.NoIdentificacion
    def set_NoIdentificacion(self, NoIdentificacion): self.NoIdentificacion = NoIdentificacion
    def get_Cantidad(self): return self.Cantidad
    def set_Cantidad(self, Cantidad): self.Cantidad = Cantidad
    def get_Unidad(self): return self.Unidad
    def set_Unidad(self, Unidad): self.Unidad = Unidad
    def get_Descripcion(self): return self.Descripcion
    def set_Descripcion(self, Descripcion): self.Descripcion = Descripcion
    def get_ValorUnitario(self): return self.ValorUnitario
    def set_ValorUnitario(self, ValorUnitario): self.ValorUnitario = ValorUnitario
    def get_Importe(self): return self.Importe
    def set_Importe(self, Importe): self.Importe = Importe
    def hasContent_(self):
        if (
            self.InformacionAduanera
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='ParteType', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='ParteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='ParteType'):
        if self.ClaveProdServ is not None and 'ClaveProdServ' not in already_processed:
            already_processed.add('ClaveProdServ')
            outfile.write(' ClaveProdServ=%s' % (quote_attrib(self.ClaveProdServ), ))
        if self.NoIdentificacion is not None and 'NoIdentificacion' not in already_processed:
            already_processed.add('NoIdentificacion')
            outfile.write(' NoIdentificacion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NoIdentificacion), input_name='NoIdentificacion')), ))
        if self.Cantidad is not None and 'Cantidad' not in already_processed:
            already_processed.add('Cantidad')
            outfile.write(' Cantidad="%s"' % self.gds_format_float(self.Cantidad, input_name='Cantidad'))
        if self.Unidad is not None and 'Unidad' not in already_processed:
            already_processed.add('Unidad')
            outfile.write(' Unidad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Unidad), input_name='Unidad')), ))
        if self.Descripcion is not None and 'Descripcion' not in already_processed:
            already_processed.add('Descripcion')
            outfile.write(' Descripcion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Descripcion), input_name='Descripcion')), ))
        if self.ValorUnitario is not None and 'ValorUnitario' not in already_processed:
            already_processed.add('ValorUnitario')
            outfile.write(' ValorUnitario=%s' % (quote_attrib(self.ValorUnitario), ))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe=%s' % (quote_attrib(self.Importe), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='ParteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for InformacionAduanera_ in self.InformacionAduanera:
            InformacionAduanera_.export(outfile, level, namespace_, name_='InformacionAduanera', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ClaveProdServ', node)
        if value is not None and 'ClaveProdServ' not in already_processed:
            already_processed.add('ClaveProdServ')
            self.ClaveProdServ = value
        value = find_attr_value_('NoIdentificacion', node)
        if value is not None and 'NoIdentificacion' not in already_processed:
            already_processed.add('NoIdentificacion')
            self.NoIdentificacion = value
        value = find_attr_value_('Cantidad', node)
        if value is not None and 'Cantidad' not in already_processed:
            already_processed.add('Cantidad')
            try:
                self.Cantidad = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (Cantidad): %s' % exp)
        value = find_attr_value_('Unidad', node)
        if value is not None and 'Unidad' not in already_processed:
            already_processed.add('Unidad')
            self.Unidad = value
        value = find_attr_value_('Descripcion', node)
        if value is not None and 'Descripcion' not in already_processed:
            already_processed.add('Descripcion')
            self.Descripcion = value
        value = find_attr_value_('ValorUnitario', node)
        if value is not None and 'ValorUnitario' not in already_processed:
            already_processed.add('ValorUnitario')
            self.ValorUnitario = value
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            self.Importe = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InformacionAduanera':
            obj_ = InformacionAduaneraType1.factory()
            obj_.build(child_)
            self.InformacionAduanera.append(obj_)
            obj_.original_tagname_ = 'InformacionAduanera'
# end class ParteType


class InformacionAduaneraType1(GeneratedsSuper):
    """Atributo requerido para expresar el número del pedimento que ampara
    la importación del bien que se expresa en el siguiente formato:
    últimos 2 dígitos del año de validación seguidos por dos
    espacios, 2 dígitos de la aduana de despacho seguidos por dos
    espacios, 4 dígitos del número de la patente seguidos por dos
    espacios, 1 dígito que corresponde al último dígito del año en
    curso, salvo que se trate de un pedimento consolidado iniciado
    en el año inmediato anterior o del pedimento original de una
    rectificación, seguido de 6 dígitos de la numeración progresiva
    por aduana."""
    subclass = None
    superclass = None
    def __init__(self, NumeroPedimento=None):
        self.original_tagname_ = None
        self.NumeroPedimento = _cast(None, NumeroPedimento)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InformacionAduaneraType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InformacionAduaneraType1.subclass:
            return InformacionAduaneraType1.subclass(*args_, **kwargs_)
        else:
            return InformacionAduaneraType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumeroPedimento(self): return self.NumeroPedimento
    def set_NumeroPedimento(self, NumeroPedimento): self.NumeroPedimento = NumeroPedimento
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='InformacionAduaneraType1', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InformacionAduaneraType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='InformacionAduaneraType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='InformacionAduaneraType1'):
        if self.NumeroPedimento is not None and 'NumeroPedimento' not in already_processed:
            already_processed.add('NumeroPedimento')
            outfile.write(' NumeroPedimento=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumeroPedimento), input_name='NumeroPedimento')), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='InformacionAduaneraType1', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NumeroPedimento', node)
        if value is not None and 'NumeroPedimento' not in already_processed:
            already_processed.add('NumeroPedimento')
            self.NumeroPedimento = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InformacionAduaneraType1


class ImpuestosType2(GeneratedsSuper):
    """Atributo condicional para expresar el total de los impuestos
    retenidos que se desprenden de los conceptos expresados en el
    comprobante fiscal digital por Internet. No se permiten valores
    negativos. Es requerido cuando en los conceptos se registren
    impuestos retenidosAtributo condicional para expresar el total
    de los impuestos trasladados que se desprenden de los conceptos
    expresados en el comprobante fiscal digital por Internet. No se
    permiten valores negativos. Es requerido cuando en los conceptos
    se registren impuestos trasladados."""
    subclass = None
    superclass = None
    def __init__(self, TotalImpuestosRetenidos=None, TotalImpuestosTrasladados=None, Retenciones=None, Traslados=None):
        self.original_tagname_ = None
        self.TotalImpuestosRetenidos = _cast(None, TotalImpuestosRetenidos)
        self.TotalImpuestosTrasladados = _cast(None, TotalImpuestosTrasladados)
        self.Retenciones = Retenciones
        self.Traslados = Traslados
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImpuestosType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImpuestosType2.subclass:
            return ImpuestosType2.subclass(*args_, **kwargs_)
        else:
            return ImpuestosType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Retenciones(self): return self.Retenciones
    def set_Retenciones(self, Retenciones): self.Retenciones = Retenciones
    def get_Traslados(self): return self.Traslados
    def set_Traslados(self, Traslados): self.Traslados = Traslados
    def get_TotalImpuestosRetenidos(self): return self.TotalImpuestosRetenidos
    def set_TotalImpuestosRetenidos(self, TotalImpuestosRetenidos): self.TotalImpuestosRetenidos = TotalImpuestosRetenidos
    def get_TotalImpuestosTrasladados(self): return self.TotalImpuestosTrasladados
    def set_TotalImpuestosTrasladados(self, TotalImpuestosTrasladados): self.TotalImpuestosTrasladados = TotalImpuestosTrasladados
    def hasContent_(self):
        if (
            self.Retenciones is not None or
            self.Traslados is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='ImpuestosType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImpuestosType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='ImpuestosType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='ImpuestosType2'):
        if self.TotalImpuestosRetenidos is not None and 'TotalImpuestosRetenidos' not in already_processed:
            already_processed.add('TotalImpuestosRetenidos')
            outfile.write(' TotalImpuestosRetenidos=%s' % (quote_attrib(self.TotalImpuestosRetenidos), ))
        if self.TotalImpuestosTrasladados is not None and 'TotalImpuestosTrasladados' not in already_processed:
            already_processed.add('TotalImpuestosTrasladados')
            outfile.write(' TotalImpuestosTrasladados=%s' % (quote_attrib(self.TotalImpuestosTrasladados), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='ImpuestosType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Retenciones is not None:
            self.Retenciones.export(outfile, level, namespace_, name_='Retenciones', pretty_print=pretty_print)
        if self.Traslados is not None:
            self.Traslados.export(outfile, level, namespace_, name_='Traslados', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TotalImpuestosRetenidos', node)
        if value is not None and 'TotalImpuestosRetenidos' not in already_processed:
            already_processed.add('TotalImpuestosRetenidos')
            self.TotalImpuestosRetenidos = value
        value = find_attr_value_('TotalImpuestosTrasladados', node)
        if value is not None and 'TotalImpuestosTrasladados' not in already_processed:
            already_processed.add('TotalImpuestosTrasladados')
            self.TotalImpuestosTrasladados = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Retenciones':
            obj_ = RetencionesType3.factory()
            obj_.build(child_)
            self.Retenciones = obj_
            obj_.original_tagname_ = 'Retenciones'
        elif nodeName_ == 'Traslados':
            obj_ = TrasladosType5.factory()
            obj_.build(child_)
            self.Traslados = obj_
            obj_.original_tagname_ = 'Traslados'
# end class ImpuestosType2


class RetencionesType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Retencion=None):
        self.original_tagname_ = None
        if Retencion is None:
            self.Retencion = []
        else:
            self.Retencion = Retencion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetencionesType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetencionesType3.subclass:
            return RetencionesType3.subclass(*args_, **kwargs_)
        else:
            return RetencionesType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Retencion(self): return self.Retencion
    def set_Retencion(self, Retencion): self.Retencion = Retencion
    def add_Retencion(self, value): self.Retencion.append(value)
    def insert_Retencion_at(self, index, value): self.Retencion.insert(index, value)
    def replace_Retencion_at(self, index, value): self.Retencion[index] = value
    def hasContent_(self):
        if (
            self.Retencion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='RetencionesType3', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RetencionesType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='RetencionesType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='RetencionesType3'):
        pass
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='RetencionesType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Retencion_ in self.Retencion:
            Retencion_.export(outfile, level, namespace_, name_='Retencion', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Retencion':
            obj_ = RetencionType4.factory()
            obj_.build(child_)
            self.Retencion.append(obj_)
            obj_.original_tagname_ = 'Retencion'
# end class RetencionesType3


class RetencionType4(GeneratedsSuper):
    """Atributo requerido para señalar la clave del tipo de impuesto
    retenidoAtributo requerido para señalar el monto del impuesto
    retenido. No se permiten valores negativos."""
    subclass = None
    superclass = None
    def __init__(self, Impuesto=None, Importe=None):
        self.original_tagname_ = None
        self.Impuesto = _cast(None, Impuesto)
        self.Importe = _cast(None, Importe)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetencionType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetencionType4.subclass:
            return RetencionType4.subclass(*args_, **kwargs_)
        else:
            return RetencionType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Impuesto(self): return self.Impuesto
    def set_Impuesto(self, Impuesto): self.Impuesto = Impuesto
    def get_Importe(self): return self.Importe
    def set_Importe(self, Importe): self.Importe = Importe
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='RetencionType4', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RetencionType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='RetencionType4', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='RetencionType4'):
        if self.Impuesto is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            outfile.write(' Impuesto=%s' % (quote_attrib(self.Impuesto), ))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe=%s' % (quote_attrib(self.Importe), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='RetencionType4', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Impuesto', node)
        if value is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            self.Impuesto = value
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            self.Importe = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RetencionType4


class TrasladosType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Traslado=None):
        self.original_tagname_ = None
        if Traslado is None:
            self.Traslado = []
        else:
            self.Traslado = Traslado
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrasladosType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrasladosType5.subclass:
            return TrasladosType5.subclass(*args_, **kwargs_)
        else:
            return TrasladosType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Traslado(self): return self.Traslado
    def set_Traslado(self, Traslado): self.Traslado = Traslado
    def add_Traslado(self, value): self.Traslado.append(value)
    def insert_Traslado_at(self, index, value): self.Traslado.insert(index, value)
    def replace_Traslado_at(self, index, value): self.Traslado[index] = value
    def hasContent_(self):
        if (
            self.Traslado
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='TrasladosType5', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrasladosType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='TrasladosType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='TrasladosType5'):
        pass
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='TrasladosType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Traslado_ in self.Traslado:
            Traslado_.export(outfile, level, namespace_, name_='Traslado', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Traslado':
            obj_ = TrasladoType6.factory()
            obj_.build(child_)
            self.Traslado.append(obj_)
            obj_.original_tagname_ = 'Traslado'
# end class TrasladosType5


class TrasladoType6(GeneratedsSuper):
    """Atributo requerido para señalar la clave del tipo de impuesto
    trasladado.Atributo requerido para señalar la clave del tipo de
    factor que se aplica a la base del impuesto.Atributo requerido
    para señalar el valor de la tasa o cuota del impuesto que se
    traslada por los conceptos amparados en el comprobante.Atributo
    requerido para señalar la suma del importe del impuesto
    trasladado, agrupado por impuesto, TipoFactor y TasaOCuota. No
    se permiten valores negativos."""
    subclass = None
    superclass = None
    def __init__(self, Impuesto=None, TipoFactor=None, TasaOCuota=None, Importe=None):
        self.original_tagname_ = None
        self.Impuesto = _cast(None, Impuesto)
        self.TipoFactor = _cast(None, TipoFactor)
        self.TasaOCuota = _cast(None, TasaOCuota)
        self.Importe = _cast(None, Importe)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrasladoType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrasladoType6.subclass:
            return TrasladoType6.subclass(*args_, **kwargs_)
        else:
            return TrasladoType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Impuesto(self): return self.Impuesto
    def set_Impuesto(self, Impuesto): self.Impuesto = Impuesto
    def get_TipoFactor(self): return self.TipoFactor
    def set_TipoFactor(self, TipoFactor): self.TipoFactor = TipoFactor
    def get_TasaOCuota(self): return self.TasaOCuota
    def set_TasaOCuota(self, TasaOCuota): self.TasaOCuota = TasaOCuota
    def get_Importe(self): return self.Importe
    def set_Importe(self, Importe): self.Importe = Importe
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='TrasladoType6', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrasladoType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='TrasladoType6', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='TrasladoType6'):
        if self.Impuesto is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            outfile.write(' Impuesto=%s' % (quote_attrib(self.Impuesto), ))
        if self.TipoFactor is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            outfile.write(' TipoFactor=%s' % (quote_attrib(self.TipoFactor), ))
        if self.TasaOCuota is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            outfile.write(' TasaOCuota=%s' % (quote_attrib(self.TasaOCuota), ))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe=%s' % (quote_attrib(self.Importe), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='TrasladoType6', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Impuesto', node)
        if value is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            self.Impuesto = value
        value = find_attr_value_('TipoFactor', node)
        if value is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            self.TipoFactor = value
        value = find_attr_value_('TasaOCuota', node)
        if value is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            self.TasaOCuota = value
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            self.Importe = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TrasladoType6


class ComplementoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ComplementoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ComplementoType.subclass:
            return ComplementoType.subclass(*args_, **kwargs_)
        else:
            return ComplementoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cce:', name_='ComplementoType', namespacedef_='', pretty_print=True, namespace_complement_=''):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComplementoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_=namespace_complement_, name_='ComplementoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='ComplementoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='ComplementoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'ComplementoType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class ComplementoType


class AddendaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AddendaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AddendaType.subclass:
            return AddendaType.subclass(*args_, **kwargs_)
        else:
            return AddendaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='AddendaType', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AddendaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='AddendaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='AddendaType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='AddendaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'AddendaType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class AddendaType


class EmisorType7(GeneratedsSuper):
    """Atributo condicional para expresar la CURP del emisor del CFDI
    cuando es una persona física."""
    subclass = None
    superclass = None
    def __init__(self, Curp=None, Domicilio=None):
        self.original_tagname_ = None
        self.Curp = _cast(None, Curp)
        self.Domicilio = Domicilio
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmisorType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmisorType7.subclass:
            return EmisorType7.subclass(*args_, **kwargs_)
        else:
            return EmisorType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domicilio(self): return self.Domicilio
    def set_Domicilio(self, Domicilio): self.Domicilio = Domicilio
    def get_Curp(self): return self.Curp
    def set_Curp(self, Curp): self.Curp = Curp
    def hasContent_(self):
        if (
            self.Domicilio is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cce11:', name_='EmisorType7', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmisorType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cce11:', name_='EmisorType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cce11:', name_='EmisorType7'):
        if self.Curp is not None and 'Curp' not in already_processed:
            already_processed.add('Curp')
            outfile.write(' Curp=%s' % (quote_attrib(self.Curp), ))
    def exportChildren(self, outfile, level, namespace_='cce11:', name_='EmisorType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Domicilio is not None:
            self.Domicilio.export(outfile, level, namespace_, name_='Domicilio', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Curp', node)
        if value is not None and 'Curp' not in already_processed:
            already_processed.add('Curp')
            self.Curp = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domicilio':
            obj_ = DomicilioType.factory()
            obj_.build(child_)
            self.Domicilio = obj_
            obj_.original_tagname_ = 'Domicilio'
# end class EmisorType7


class DomicilioType(GeneratedsSuper):
    """Atributo requerido sirve para precisar la calle en que está ubicado
    el domicilio del emisor del comprobante.Atributo opcional que
    sirve para expresar el número exterior en donde se ubica el
    domicilio del emisor del comprobante.Atributo opcional que sirve
    para expresar el número interior, en caso de existir, en donde
    se ubica el domicilio del emisor del comprobante.Atributo
    opcional que sirve para expresar la clave de la colonia en donde
    se ubica el domicilio del emisor del comprobante, conforme con
    el catálogo c_Colonia publicado en el portal del SAT en
    internet.Atributo opcional que sirve para precisar la clave de
    la ciudad, población, distrito u otro análogo en donde se ubica
    el domicilio del emisor del comprobante, conforme con el
    catálogo c_Localidad publicado en el portal del SAT en
    internet.Atributo opcional para expresar una referencia
    geográfica adicional que permita una más fácil o precisa
    ubicación del domicilio del emisor del comprobante, por ejemplo
    las coordenadas GPS.Atributo opcional que sirve para precisar la
    clave del municipio o delegación en donde se encuentra ubicado
    el domicilio del emisor del comprobante, conforme con el
    catálogo c_Municipio publicado en el portal del SAT en
    internet.Atributo requerido para señalar la clave del estado en
    donde se encuentra ubicado el domicilio del emisor del
    comprobante, conforme con el catálogo c_Estado publicado en el
    portal del SAT en internet que está basado en la especificación
    ISO 3166-2.Atributo requerido que sirve para precisar la clave
    del país donde se encuentra ubicado el domicilio del emisor del
    comprobante, conforme con el catálogo c_Pais publicado en el
    portal del SAT en internet que está basado en la especificación
    ISO 3166-1. Debe tener el valor MEX.Atributo requerido que sirve
    para asentar la clave del código postal en donde se encuentra
    ubicado el domicilio del emisor del comprobante, conforme con el
    catálogo c_CodigoPostal publicado en el portal del SAT en
    internet."""
    subclass = None
    superclass = None
    def __init__(self, Calle=None, NumeroExterior=None, NumeroInterior=None, Colonia=None, Localidad=None, Referencia=None, Municipio=None, Estado=None, Pais=None, CodigoPostal=None):
        self.original_tagname_ = None
        self.Calle = _cast(None, Calle)
        self.NumeroExterior = _cast(None, NumeroExterior)
        self.NumeroInterior = _cast(None, NumeroInterior)
        self.Colonia = _cast(None, Colonia)
        self.Localidad = _cast(None, Localidad)
        self.Referencia = _cast(None, Referencia)
        self.Municipio = _cast(None, Municipio)
        self.Estado = _cast(None, Estado)
        self.Pais = _cast(None, Pais)
        self.CodigoPostal = _cast(None, CodigoPostal)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DomicilioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DomicilioType.subclass:
            return DomicilioType.subclass(*args_, **kwargs_)
        else:
            return DomicilioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Calle(self): return self.Calle
    def set_Calle(self, Calle): self.Calle = Calle
    def get_NumeroExterior(self): return self.NumeroExterior
    def set_NumeroExterior(self, NumeroExterior): self.NumeroExterior = NumeroExterior
    def get_NumeroInterior(self): return self.NumeroInterior
    def set_NumeroInterior(self, NumeroInterior): self.NumeroInterior = NumeroInterior
    def get_Colonia(self): return self.Colonia
    def set_Colonia(self, Colonia): self.Colonia = Colonia
    def get_Localidad(self): return self.Localidad
    def set_Localidad(self, Localidad): self.Localidad = Localidad
    def get_Referencia(self): return self.Referencia
    def set_Referencia(self, Referencia): self.Referencia = Referencia
    def get_Municipio(self): return self.Municipio
    def set_Municipio(self, Municipio): self.Municipio = Municipio
    def get_Estado(self): return self.Estado
    def set_Estado(self, Estado): self.Estado = Estado
    def get_Pais(self): return self.Pais
    def set_Pais(self, Pais): self.Pais = Pais
    def get_CodigoPostal(self): return self.CodigoPostal
    def set_CodigoPostal(self, CodigoPostal): self.CodigoPostal = CodigoPostal
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='DomicilioType', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomicilioType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='DomicilioType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='DomicilioType'):
        if self.Calle is not None and 'Calle' not in already_processed:
            already_processed.add('Calle')
            outfile.write(' Calle=%s' % (quote_attrib(self.Calle), ))
        if self.NumeroExterior is not None and 'NumeroExterior' not in already_processed:
            already_processed.add('NumeroExterior')
            outfile.write(' NumeroExterior=%s' % (quote_attrib(self.NumeroExterior), ))
        if self.NumeroInterior is not None and 'NumeroInterior' not in already_processed:
            already_processed.add('NumeroInterior')
            outfile.write(' NumeroInterior=%s' % (quote_attrib(self.NumeroInterior), ))
        if self.Colonia is not None and 'Colonia' not in already_processed:
            already_processed.add('Colonia')
            outfile.write(' Colonia=%s' % (quote_attrib(self.Colonia), ))
        if self.Localidad is not None and 'Localidad' not in already_processed:
            already_processed.add('Localidad')
            outfile.write(' Localidad=%s' % (quote_attrib(self.Localidad), ))
        if self.Referencia is not None and 'Referencia' not in already_processed:
            already_processed.add('Referencia')
            outfile.write(' Referencia=%s' % (quote_attrib(self.Referencia), ))
        if self.Municipio is not None and 'Municipio' not in already_processed:
            already_processed.add('Municipio')
            outfile.write(' Municipio=%s' % (quote_attrib(self.Municipio), ))
        if self.Estado is not None and 'Estado' not in already_processed:
            already_processed.add('Estado')
            outfile.write(' Estado=%s' % (quote_attrib(self.Estado), ))
        if self.Pais is not None and 'Pais' not in already_processed:
            already_processed.add('Pais')
            outfile.write(' Pais=%s' % (quote_attrib(self.Pais), ))
        if self.CodigoPostal is not None and 'CodigoPostal' not in already_processed:
            already_processed.add('CodigoPostal')
            outfile.write(' CodigoPostal=%s' % (quote_attrib(self.CodigoPostal), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='DomicilioType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Calle', node)
        if value is not None and 'Calle' not in already_processed:
            already_processed.add('Calle')
            self.Calle = value
        value = find_attr_value_('NumeroExterior', node)
        if value is not None and 'NumeroExterior' not in already_processed:
            already_processed.add('NumeroExterior')
            self.NumeroExterior = value
        value = find_attr_value_('NumeroInterior', node)
        if value is not None and 'NumeroInterior' not in already_processed:
            already_processed.add('NumeroInterior')
            self.NumeroInterior = value
        value = find_attr_value_('Colonia', node)
        if value is not None and 'Colonia' not in already_processed:
            already_processed.add('Colonia')
            self.Colonia = value
        value = find_attr_value_('Localidad', node)
        if value is not None and 'Localidad' not in already_processed:
            already_processed.add('Localidad')
            self.Localidad = value
        value = find_attr_value_('Referencia', node)
        if value is not None and 'Referencia' not in already_processed:
            already_processed.add('Referencia')
            self.Referencia = value
        value = find_attr_value_('Municipio', node)
        if value is not None and 'Municipio' not in already_processed:
            already_processed.add('Municipio')
            self.Municipio = value
        value = find_attr_value_('Estado', node)
        if value is not None and 'Estado' not in already_processed:
            already_processed.add('Estado')
            self.Estado = value
        value = find_attr_value_('Pais', node)
        if value is not None and 'Pais' not in already_processed:
            already_processed.add('Pais')
            self.Pais = value
        value = find_attr_value_('CodigoPostal', node)
        if value is not None and 'CodigoPostal' not in already_processed:
            already_processed.add('CodigoPostal')
            self.CodigoPostal = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DomicilioType


class PropietarioType(GeneratedsSuper):
    """Atributo requerido para incorporar el número de identificación o
    registro fiscal del país de residencia para efectos fiscales del
    propietario de la mercancía trasladada.Atributo requerido para
    registrar la clave del país de residencia para efectos fiscales
    del propietario de la mercancía, conforme con el catálogo c_Pais
    publicado en el portal del SAT en internet que está basado en la
    especificación ISO 3166-1."""
    subclass = None
    superclass = None
    def __init__(self, NumRegIdTrib=None, ResidenciaFiscal=None):
        self.original_tagname_ = None
        self.NumRegIdTrib = _cast(None, NumRegIdTrib)
        self.ResidenciaFiscal = _cast(None, ResidenciaFiscal)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PropietarioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PropietarioType.subclass:
            return PropietarioType.subclass(*args_, **kwargs_)
        else:
            return PropietarioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumRegIdTrib(self): return self.NumRegIdTrib
    def set_NumRegIdTrib(self, NumRegIdTrib): self.NumRegIdTrib = NumRegIdTrib
    def get_ResidenciaFiscal(self): return self.ResidenciaFiscal
    def set_ResidenciaFiscal(self, ResidenciaFiscal): self.ResidenciaFiscal = ResidenciaFiscal
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='PropietarioType', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropietarioType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='PropietarioType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='PropietarioType'):
        if self.NumRegIdTrib is not None and 'NumRegIdTrib' not in already_processed:
            already_processed.add('NumRegIdTrib')
            outfile.write(' NumRegIdTrib=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumRegIdTrib), input_name='NumRegIdTrib')), ))
        if self.ResidenciaFiscal is not None and 'ResidenciaFiscal' not in already_processed:
            already_processed.add('ResidenciaFiscal')
            outfile.write(' ResidenciaFiscal=%s' % (quote_attrib(self.ResidenciaFiscal), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='PropietarioType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NumRegIdTrib', node)
        if value is not None and 'NumRegIdTrib' not in already_processed:
            already_processed.add('NumRegIdTrib')
            self.NumRegIdTrib = value
        value = find_attr_value_('ResidenciaFiscal', node)
        if value is not None and 'ResidenciaFiscal' not in already_processed:
            already_processed.add('ResidenciaFiscal')
            self.ResidenciaFiscal = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PropietarioType


class ReceptorType8(GeneratedsSuper):
    """Atributo condicional para incorporar el número de identificación o
    registro fiscal del país de residencia para efectos fiscales del
    receptor del CFDI."""
    subclass = None
    superclass = None
    def __init__(self, NumRegIdTrib=None, Domicilio=None):
        self.original_tagname_ = None
        self.NumRegIdTrib = _cast(None, NumRegIdTrib)
        self.Domicilio = Domicilio
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReceptorType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReceptorType8.subclass:
            return ReceptorType8.subclass(*args_, **kwargs_)
        else:
            return ReceptorType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domicilio(self): return self.Domicilio
    def set_Domicilio(self, Domicilio): self.Domicilio = Domicilio
    def get_NumRegIdTrib(self): return self.NumRegIdTrib
    def set_NumRegIdTrib(self, NumRegIdTrib): self.NumRegIdTrib = NumRegIdTrib
    def hasContent_(self):
        if (
            self.Domicilio is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cce11:', name_='ReceptorType8', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReceptorType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cce11:', name_='ReceptorType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cce11:', name_='ReceptorType8'):
        if self.NumRegIdTrib is not None and 'NumRegIdTrib' not in already_processed:
            already_processed.add('NumRegIdTrib')
            outfile.write(' NumRegIdTrib=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumRegIdTrib), input_name='NumRegIdTrib')), ))
    def exportChildren(self, outfile, level, namespace_='cce11:', name_='ReceptorType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Domicilio is not None:
            self.Domicilio.export(outfile, level, namespace_, name_='Domicilio', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NumRegIdTrib', node)
        if value is not None and 'NumRegIdTrib' not in already_processed:
            already_processed.add('NumRegIdTrib')
            self.NumRegIdTrib = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domicilio':
            obj_ = DomicilioType9.factory()
            obj_.build(child_)
            self.Domicilio = obj_
            obj_.original_tagname_ = 'Domicilio'
# end class ReceptorType8


class DomicilioType9(GeneratedsSuper):
    """Atributo requerido sirve para precisar la calle en que está ubicado
    el domicilio del receptor del comprobante.Atributo opcional
    sirve para expresar el número exterior en donde se ubica el
    domicilio del receptor del comprobante.Atributo opcional sirve
    para expresar el número interior, en caso de existir, en donde
    se ubica el domicilio del receptor del comprobante.Atributo
    opcional sirve para expresar la colonia o dato análogo en donde
    se ubica el domicilio del receptor del comprobante.Atributo
    opcional que sirve para precisar la ciudad, población, distrito
    u otro análogo en donde se ubica el domicilio del receptor del
    comprobante.Atributo opcional para expresar una referencia
    geográfica adicional que permita una más fácil o precisa
    ubicación del domicilio del receptor del comprobante, por
    ejemplo las coordenadas GPS.Atributo opcional que sirve para
    precisar el municipio, delegación, condado u otro análogo en
    donde se encuentra ubicado el domicilio del receptor del
    comprobante.Atributo requerido para señalar el estado, entidad,
    región, comunidad u otra figura análoga en donde se encuentra
    ubicado el domicilio del receptor del comprobante. El catálogo
    se publica en el portal del SAT en internet y será conforme con
    la especificación ISO 3166-2.Atributo requerido que sirve para
    precisar la clave del país donde se encuentra ubicado el
    domicilio del receptor del comprobante, conforme con el catálogo
    c_Pais publicado en el portal del SAT en internet que está
    basado en la especificación ISO 3166-1.Atributo requerido que
    sirve para asentar el código postal (PO, BOX) en donde se
    encuentra ubicado el domicilio del receptor del comprobante."""
    subclass = None
    superclass = None
    def __init__(self, Calle=None, NumeroExterior=None, NumeroInterior=None, Colonia=None, Localidad=None, Referencia=None, Municipio=None, Estado=None, Pais=None, CodigoPostal=None):
        self.original_tagname_ = None
        self.Calle = _cast(None, Calle)
        self.NumeroExterior = _cast(None, NumeroExterior)
        self.NumeroInterior = _cast(None, NumeroInterior)
        self.Colonia = _cast(None, Colonia)
        self.Localidad = _cast(None, Localidad)
        self.Referencia = _cast(None, Referencia)
        self.Municipio = _cast(None, Municipio)
        self.Estado = _cast(None, Estado)
        self.Pais = _cast(None, Pais)
        self.CodigoPostal = _cast(None, CodigoPostal)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DomicilioType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DomicilioType9.subclass:
            return DomicilioType9.subclass(*args_, **kwargs_)
        else:
            return DomicilioType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Calle(self): return self.Calle
    def set_Calle(self, Calle): self.Calle = Calle
    def get_NumeroExterior(self): return self.NumeroExterior
    def set_NumeroExterior(self, NumeroExterior): self.NumeroExterior = NumeroExterior
    def get_NumeroInterior(self): return self.NumeroInterior
    def set_NumeroInterior(self, NumeroInterior): self.NumeroInterior = NumeroInterior
    def get_Colonia(self): return self.Colonia
    def set_Colonia(self, Colonia): self.Colonia = Colonia
    def get_Localidad(self): return self.Localidad
    def set_Localidad(self, Localidad): self.Localidad = Localidad
    def get_Referencia(self): return self.Referencia
    def set_Referencia(self, Referencia): self.Referencia = Referencia
    def get_Municipio(self): return self.Municipio
    def set_Municipio(self, Municipio): self.Municipio = Municipio
    def get_Estado(self): return self.Estado
    def set_Estado(self, Estado): self.Estado = Estado
    def get_Pais(self): return self.Pais
    def set_Pais(self, Pais): self.Pais = Pais
    def get_CodigoPostal(self): return self.CodigoPostal
    def set_CodigoPostal(self, CodigoPostal): self.CodigoPostal = CodigoPostal
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='DomicilioType9', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomicilioType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='DomicilioType9', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='DomicilioType9'):
        if self.Calle is not None and 'Calle' not in already_processed:
            already_processed.add('Calle')
            outfile.write(' Calle=%s' % (quote_attrib(self.Calle), ))
        if self.NumeroExterior is not None and 'NumeroExterior' not in already_processed:
            already_processed.add('NumeroExterior')
            outfile.write(' NumeroExterior=%s' % (quote_attrib(self.NumeroExterior), ))
        if self.NumeroInterior is not None and 'NumeroInterior' not in already_processed:
            already_processed.add('NumeroInterior')
            outfile.write(' NumeroInterior=%s' % (quote_attrib(self.NumeroInterior), ))
        if self.Colonia is not None and 'Colonia' not in already_processed:
            already_processed.add('Colonia')
            outfile.write(' Colonia=%s' % (quote_attrib(self.Colonia), ))
        if self.Localidad is not None and 'Localidad' not in already_processed:
            already_processed.add('Localidad')
            outfile.write(' Localidad=%s' % (quote_attrib(self.Localidad), ))
        if self.Referencia is not None and 'Referencia' not in already_processed:
            already_processed.add('Referencia')
            outfile.write(' Referencia=%s' % (quote_attrib(self.Referencia), ))
        if self.Municipio is not None and 'Municipio' not in already_processed:
            already_processed.add('Municipio')
            outfile.write(' Municipio=%s' % (quote_attrib(self.Municipio), ))
        if self.Estado is not None and 'Estado' not in already_processed:
            already_processed.add('Estado')
            outfile.write(' Estado=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Estado), input_name='Estado')), ))
        if self.Pais is not None and 'Pais' not in already_processed:
            already_processed.add('Pais')
            outfile.write(' Pais=%s' % (quote_attrib(self.Pais), ))
        if self.CodigoPostal is not None and 'CodigoPostal' not in already_processed:
            already_processed.add('CodigoPostal')
            outfile.write(' CodigoPostal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CodigoPostal), input_name='CodigoPostal')), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='DomicilioType9', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Calle', node)
        if value is not None and 'Calle' not in already_processed:
            already_processed.add('Calle')
            self.Calle = value
        value = find_attr_value_('NumeroExterior', node)
        if value is not None and 'NumeroExterior' not in already_processed:
            already_processed.add('NumeroExterior')
            self.NumeroExterior = value
        value = find_attr_value_('NumeroInterior', node)
        if value is not None and 'NumeroInterior' not in already_processed:
            already_processed.add('NumeroInterior')
            self.NumeroInterior = value
        value = find_attr_value_('Colonia', node)
        if value is not None and 'Colonia' not in already_processed:
            already_processed.add('Colonia')
            self.Colonia = value
        value = find_attr_value_('Localidad', node)
        if value is not None and 'Localidad' not in already_processed:
            already_processed.add('Localidad')
            self.Localidad = value
        value = find_attr_value_('Referencia', node)
        if value is not None and 'Referencia' not in already_processed:
            already_processed.add('Referencia')
            self.Referencia = value
        value = find_attr_value_('Municipio', node)
        if value is not None and 'Municipio' not in already_processed:
            already_processed.add('Municipio')
            self.Municipio = value
        value = find_attr_value_('Estado', node)
        if value is not None and 'Estado' not in already_processed:
            already_processed.add('Estado')
            self.Estado = value
        value = find_attr_value_('Pais', node)
        if value is not None and 'Pais' not in already_processed:
            already_processed.add('Pais')
            self.Pais = value
        value = find_attr_value_('CodigoPostal', node)
        if value is not None and 'CodigoPostal' not in already_processed:
            already_processed.add('CodigoPostal')
            self.CodigoPostal = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DomicilioType9


class DestinatarioType(GeneratedsSuper):
    """Atributo opcional para incorporar el número de identificación o
    registro fiscal del país de residencia para efectos fiscales del
    destinatario de la mercancía exportada.Atributo opcional para
    expresar el nombre completo, denominación o razón social del
    destinatario de la mercancía exportada."""
    subclass = None
    superclass = None
    def __init__(self, NumRegIdTrib=None, Nombre=None, Domicilio=None):
        self.original_tagname_ = None
        self.NumRegIdTrib = _cast(None, NumRegIdTrib)
        self.Nombre = _cast(None, Nombre)
        if Domicilio is None:
            self.Domicilio = []
        else:
            self.Domicilio = Domicilio
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DestinatarioType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DestinatarioType.subclass:
            return DestinatarioType.subclass(*args_, **kwargs_)
        else:
            return DestinatarioType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domicilio(self): return self.Domicilio
    def set_Domicilio(self, Domicilio): self.Domicilio = Domicilio
    def add_Domicilio(self, value): self.Domicilio.append(value)
    def insert_Domicilio_at(self, index, value): self.Domicilio.insert(index, value)
    def replace_Domicilio_at(self, index, value): self.Domicilio[index] = value
    def get_NumRegIdTrib(self): return self.NumRegIdTrib
    def set_NumRegIdTrib(self, NumRegIdTrib): self.NumRegIdTrib = NumRegIdTrib
    def get_Nombre(self): return self.Nombre
    def set_Nombre(self, Nombre): self.Nombre = Nombre
    def hasContent_(self):
        if (
            self.Domicilio
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cce11:', name_='DestinatarioType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DestinatarioType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cce11:', name_='DestinatarioType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cce11:', name_='DestinatarioType'):
        if self.NumRegIdTrib is not None and 'NumRegIdTrib' not in already_processed:
            already_processed.add('NumRegIdTrib')
            outfile.write(' NumRegIdTrib=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumRegIdTrib), input_name='NumRegIdTrib')), ))
        if self.Nombre is not None and 'Nombre' not in already_processed:
            already_processed.add('Nombre')
            outfile.write(' Nombre=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Nombre), input_name='Nombre')), ))
    def exportChildren(self, outfile, level, namespace_='cce11:', name_='DestinatarioType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Domicilio_ in self.Domicilio:
            Domicilio_.export(outfile, level, namespace_, name_='Domicilio', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NumRegIdTrib', node)
        if value is not None and 'NumRegIdTrib' not in already_processed:
            already_processed.add('NumRegIdTrib')
            self.NumRegIdTrib = value
        value = find_attr_value_('Nombre', node)
        if value is not None and 'Nombre' not in already_processed:
            already_processed.add('Nombre')
            self.Nombre = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domicilio':
            obj_ = DomicilioType10.factory()
            obj_.build(child_)
            self.Domicilio.append(obj_)
            obj_.original_tagname_ = 'Domicilio'
# end class DestinatarioType


class DomicilioType10(GeneratedsSuper):
    """Atributo requerido sirve para precisar la calle en que está ubicado
    el domicilio del destinatario de la mercancía.Atributo opcional
    sirve para expresar el número exterior en donde se ubica el
    domicilio del destinatario de la mercancía.Atributo opcional
    sirve para expresar el número interior, en caso de existir, en
    donde se ubica el domicilio del destinatario de la
    mercancía.Atributo opcional sirve para expresar la colonia o
    dato análogo en donde se ubica el domicilio del destinatario de
    la mercancía.Atributo opcional que sirve para precisar la
    ciudad, población, distrito u otro análogo en donde se ubica el
    domicilio del destinatario de la mercancía.Atributo opcional
    para expresar una referencia geográfica adicional que permita
    una fácil o precisa ubicación del domicilio del destinatario de
    la mercancía, por ejemplo las coordenadas GPS.Atributo opcional
    que sirve para precisar el municipio, delegación, condado u otro
    análogo en donde se encuentra ubicado el destinatario de la
    mercancía.Atributo requerido para señalar el estado, entidad,
    región, comunidad u otra figura análoga en donde se encuentra
    ubicado el domicilio del destinatario de la mercancía. El
    catálogo se publica en el portal del SAT en internet y es
    conforme con la especificación ISO 3166-2. Atributo requerido
    que sirve para precisar la clave del país donde se encuentra
    ubicado el destinatario de la mercancía, conforme con el
    catálogo c_Pais publicado en el portal del SAT en internet que
    está basado en la especificación ISO 3166-1.Atributo requerido
    que sirve para asentar el código postal (PO, BOX) en donde se
    encuentra ubicado el domicilio del destinatario de la mercancía."""
    subclass = None
    superclass = None
    def __init__(self, Calle=None, NumeroExterior=None, NumeroInterior=None, Colonia=None, Localidad=None, Referencia=None, Municipio=None, Estado=None, Pais=None, CodigoPostal=None):
        self.original_tagname_ = None
        self.Calle = _cast(None, Calle)
        self.NumeroExterior = _cast(None, NumeroExterior)
        self.NumeroInterior = _cast(None, NumeroInterior)
        self.Colonia = _cast(None, Colonia)
        self.Localidad = _cast(None, Localidad)
        self.Referencia = _cast(None, Referencia)
        self.Municipio = _cast(None, Municipio)
        self.Estado = _cast(None, Estado)
        self.Pais = _cast(None, Pais)
        self.CodigoPostal = _cast(None, CodigoPostal)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DomicilioType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DomicilioType10.subclass:
            return DomicilioType10.subclass(*args_, **kwargs_)
        else:
            return DomicilioType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Calle(self): return self.Calle
    def set_Calle(self, Calle): self.Calle = Calle
    def get_NumeroExterior(self): return self.NumeroExterior
    def set_NumeroExterior(self, NumeroExterior): self.NumeroExterior = NumeroExterior
    def get_NumeroInterior(self): return self.NumeroInterior
    def set_NumeroInterior(self, NumeroInterior): self.NumeroInterior = NumeroInterior
    def get_Colonia(self): return self.Colonia
    def set_Colonia(self, Colonia): self.Colonia = Colonia
    def get_Localidad(self): return self.Localidad
    def set_Localidad(self, Localidad): self.Localidad = Localidad
    def get_Referencia(self): return self.Referencia
    def set_Referencia(self, Referencia): self.Referencia = Referencia
    def get_Municipio(self): return self.Municipio
    def set_Municipio(self, Municipio): self.Municipio = Municipio
    def get_Estado(self): return self.Estado
    def set_Estado(self, Estado): self.Estado = Estado
    def get_Pais(self): return self.Pais
    def set_Pais(self, Pais): self.Pais = Pais
    def get_CodigoPostal(self): return self.CodigoPostal
    def set_CodigoPostal(self, CodigoPostal): self.CodigoPostal = CodigoPostal
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cce11:', name_='DomicilioType10', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DomicilioType10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cce11:', name_='DomicilioType10', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cce11:', name_='DomicilioType10'):
        if self.Calle is not None and 'Calle' not in already_processed:
            already_processed.add('Calle')
            outfile.write(' Calle=%s' % (quote_attrib(self.Calle), ))
        if self.NumeroExterior is not None and 'NumeroExterior' not in already_processed:
            already_processed.add('NumeroExterior')
            outfile.write(' NumeroExterior=%s' % (quote_attrib(self.NumeroExterior), ))
        if self.NumeroInterior is not None and 'NumeroInterior' not in already_processed:
            already_processed.add('NumeroInterior')
            outfile.write(' NumeroInterior=%s' % (quote_attrib(self.NumeroInterior), ))
        if self.Colonia is not None and 'Colonia' not in already_processed:
            already_processed.add('Colonia')
            outfile.write(' Colonia=%s' % (quote_attrib(self.Colonia), ))
        if self.Localidad is not None and 'Localidad' not in already_processed:
            already_processed.add('Localidad')
            outfile.write(' Localidad=%s' % (quote_attrib(self.Localidad), ))
        if self.Referencia is not None and 'Referencia' not in already_processed:
            already_processed.add('Referencia')
            outfile.write(' Referencia=%s' % (quote_attrib(self.Referencia), ))
        if self.Municipio is not None and 'Municipio' not in already_processed:
            already_processed.add('Municipio')
            outfile.write(' Municipio=%s' % (quote_attrib(self.Municipio), ))
        if self.Estado is not None and 'Estado' not in already_processed:
            already_processed.add('Estado')
            outfile.write(' Estado=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Estado), input_name='Estado')), ))
        if self.Pais is not None and 'Pais' not in already_processed:
            already_processed.add('Pais')
            outfile.write(' Pais=%s' % (quote_attrib(self.Pais), ))
        if self.CodigoPostal is not None and 'CodigoPostal' not in already_processed:
            already_processed.add('CodigoPostal')
            outfile.write(' CodigoPostal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CodigoPostal), input_name='CodigoPostal')), ))
    def exportChildren(self, outfile, level, namespace_='cce11:', name_='DomicilioType10', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Calle', node)
        if value is not None and 'Calle' not in already_processed:
            already_processed.add('Calle')
            self.Calle = value
        value = find_attr_value_('NumeroExterior', node)
        if value is not None and 'NumeroExterior' not in already_processed:
            already_processed.add('NumeroExterior')
            self.NumeroExterior = value
        value = find_attr_value_('NumeroInterior', node)
        if value is not None and 'NumeroInterior' not in already_processed:
            already_processed.add('NumeroInterior')
            self.NumeroInterior = value
        value = find_attr_value_('Colonia', node)
        if value is not None and 'Colonia' not in already_processed:
            already_processed.add('Colonia')
            self.Colonia = value
        value = find_attr_value_('Localidad', node)
        if value is not None and 'Localidad' not in already_processed:
            already_processed.add('Localidad')
            self.Localidad = value
        value = find_attr_value_('Referencia', node)
        if value is not None and 'Referencia' not in already_processed:
            already_processed.add('Referencia')
            self.Referencia = value
        value = find_attr_value_('Municipio', node)
        if value is not None and 'Municipio' not in already_processed:
            already_processed.add('Municipio')
            self.Municipio = value
        value = find_attr_value_('Estado', node)
        if value is not None and 'Estado' not in already_processed:
            already_processed.add('Estado')
            self.Estado = value
        value = find_attr_value_('Pais', node)
        if value is not None and 'Pais' not in already_processed:
            already_processed.add('Pais')
            self.Pais = value
        value = find_attr_value_('CodigoPostal', node)
        if value is not None and 'CodigoPostal' not in already_processed:
            already_processed.add('CodigoPostal')
            self.CodigoPostal = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DomicilioType10


class MercanciasType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Mercancia=None):
        self.original_tagname_ = None
        if Mercancia is None:
            self.Mercancia = []
        else:
            self.Mercancia = Mercancia
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MercanciasType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MercanciasType.subclass:
            return MercanciasType.subclass(*args_, **kwargs_)
        else:
            return MercanciasType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Mercancia(self): return self.Mercancia
    def set_Mercancia(self, Mercancia): self.Mercancia = Mercancia
    def add_Mercancia(self, value): self.Mercancia.append(value)
    def insert_Mercancia_at(self, index, value): self.Mercancia.insert(index, value)
    def replace_Mercancia_at(self, index, value): self.Mercancia[index] = value
    def hasContent_(self):
        if (
            self.Mercancia
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cce11:', name_='MercanciasType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MercanciasType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cce11:', name_='MercanciasType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cce11:', name_='MercanciasType'):
        pass
    def exportChildren(self, outfile, level, namespace_='cce11:', name_='MercanciasType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Mercancia_ in self.Mercancia:
            Mercancia_.export(outfile, level, namespace_, name_='Mercancia', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Mercancia':
            obj_ = MercanciaType.factory()
            obj_.build(child_)
            self.Mercancia.append(obj_)
            obj_.original_tagname_ = 'Mercancia'
# end class MercanciasType


class MercanciaType(GeneratedsSuper):
    """Atributo requerido que sirve para expresar el número de parte, la
    clave de identificación que asigna la empresa o el número de
    serie de la mercancía exportada.Atributo condicional que sirve
    para expresar la clave de la fracción arancelaria
    correspondiente a la descripción de la mercancía exportada, este
    dato se vuelve requerido cuando se cuente con él o se esté
    obligado legalmente a contar con él.Debe ser conforme con el
    catálogo c_FraccionArancelaria publicado en el portal del SAT en
    internet.Atributo opcional para precisar la cantidad de bienes
    en la aduana conforme a la UnidadAduana cuando en el nodo
    Comprobante:Conceptos:Concepto se hubiera registrado información
    comercial.Atributo condicional para precisar la clave de la
    unidad de medida aplicable para la cantidad expresada en la
    mercancía en la aduana, conforme con el catálogo c_UnidadAduana
    publicado en el portal del SAT en internet.Atributo condicional
    para precisar el valor o precio unitario del bien en la aduana.
    Se expresa en dólares de Estados Unidos (USD), el cual puede
    estar registrado hasta centésimas.Atributo requerido que indica
    el valor total en dólares de Estados Unidos (USD)."""
    subclass = None
    superclass = None
    def __init__(self, NoIdentificacion=None, FraccionArancelaria=None, CantidadAduana=None, UnidadAduana=None, ValorUnitarioAduana=None, ValorDolares=None, DescripcionesEspecificas=None):
        self.original_tagname_ = None
        self.NoIdentificacion = _cast(None, NoIdentificacion)
        self.FraccionArancelaria = _cast(None, FraccionArancelaria)
        #self.CantidadAduana = _cast(float, CantidadAduana)
        self.CantidadAduana = _cast(None, CantidadAduana)
        self.UnidadAduana = _cast(None, UnidadAduana)
        #self.ValorUnitarioAduana = _cast(float, ValorUnitarioAduana)
        self.ValorUnitarioAduana = _cast(None, ValorUnitarioAduana)
        #self.ValorDolares = _cast(float, ValorDolares)
        self.ValorDolares = _cast(None, ValorDolares)
        if DescripcionesEspecificas is None:
            self.DescripcionesEspecificas = []
        else:
            self.DescripcionesEspecificas = DescripcionesEspecificas
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MercanciaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MercanciaType.subclass:
            return MercanciaType.subclass(*args_, **kwargs_)
        else:
            return MercanciaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DescripcionesEspecificas(self): return self.DescripcionesEspecificas
    def set_DescripcionesEspecificas(self, DescripcionesEspecificas): self.DescripcionesEspecificas = DescripcionesEspecificas
    def add_DescripcionesEspecificas(self, value): self.DescripcionesEspecificas.append(value)
    def insert_DescripcionesEspecificas_at(self, index, value): self.DescripcionesEspecificas.insert(index, value)
    def replace_DescripcionesEspecificas_at(self, index, value): self.DescripcionesEspecificas[index] = value
    def get_NoIdentificacion(self): return self.NoIdentificacion
    def set_NoIdentificacion(self, NoIdentificacion): self.NoIdentificacion = NoIdentificacion
    def get_FraccionArancelaria(self): return self.FraccionArancelaria
    def set_FraccionArancelaria(self, FraccionArancelaria): self.FraccionArancelaria = FraccionArancelaria
    def get_CantidadAduana(self): return self.CantidadAduana
    def set_CantidadAduana(self, CantidadAduana): self.CantidadAduana = CantidadAduana
    def get_UnidadAduana(self): return self.UnidadAduana
    def set_UnidadAduana(self, UnidadAduana): self.UnidadAduana = UnidadAduana
    def get_ValorUnitarioAduana(self): return self.ValorUnitarioAduana
    def set_ValorUnitarioAduana(self, ValorUnitarioAduana): self.ValorUnitarioAduana = ValorUnitarioAduana
    def get_ValorDolares(self): return self.ValorDolares
    def set_ValorDolares(self, ValorDolares): self.ValorDolares = ValorDolares
    def hasContent_(self):
        if (
            self.DescripcionesEspecificas
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cce11:', name_='MercanciaType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MercanciaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cce11:', name_='MercanciaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cce11:', name_='MercanciaType'):
        if self.NoIdentificacion is not None and 'NoIdentificacion' not in already_processed:
            already_processed.add('NoIdentificacion')
            outfile.write(' NoIdentificacion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NoIdentificacion), input_name='NoIdentificacion')), ))
        if self.FraccionArancelaria is not None and 'FraccionArancelaria' not in already_processed:
            already_processed.add('FraccionArancelaria')
            outfile.write(' FraccionArancelaria=%s' % (quote_attrib(self.FraccionArancelaria), ))
        if self.CantidadAduana is not None and 'CantidadAduana' not in already_processed:
            already_processed.add('CantidadAduana')
            #outfile.write(' CantidadAduana="%s"' % self.gds_format_float(self.CantidadAduana, input_name='CantidadAduana'))
            outfile.write(' CantidadAduana="%s"' % self.CantidadAduana)
        if self.UnidadAduana is not None and 'UnidadAduana' not in already_processed:
            already_processed.add('UnidadAduana')
            outfile.write(' UnidadAduana=%s' % (quote_attrib(self.UnidadAduana), ))
        if self.ValorUnitarioAduana is not None and 'ValorUnitarioAduana' not in already_processed:
            already_processed.add('ValorUnitarioAduana')
            #outfile.write(' ValorUnitarioAduana="%s"' % self.gds_format_float(self.ValorUnitarioAduana, input_name='ValorUnitarioAduana'))
            outfile.write(' ValorUnitarioAduana="%s"' % self.ValorUnitarioAduana)
        if self.ValorDolares is not None and 'ValorDolares' not in already_processed:
            already_processed.add('ValorDolares')
            #outfile.write(' ValorDolares="%s"' % self.gds_format_float(self.ValorDolares, input_name='ValorDolares'))
            outfile.write(' ValorDolares="%s"' % self.ValorDolares)
    def exportChildren(self, outfile, level, namespace_='cce11:', name_='MercanciaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DescripcionesEspecificas_ in self.DescripcionesEspecificas:
            DescripcionesEspecificas_.export(outfile, level, namespace_, name_='DescripcionesEspecificas', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NoIdentificacion', node)
        if value is not None and 'NoIdentificacion' not in already_processed:
            already_processed.add('NoIdentificacion')
            self.NoIdentificacion = value
        value = find_attr_value_('FraccionArancelaria', node)
        if value is not None and 'FraccionArancelaria' not in already_processed:
            already_processed.add('FraccionArancelaria')
            self.FraccionArancelaria = value
        value = find_attr_value_('CantidadAduana', node)
        if value is not None and 'CantidadAduana' not in already_processed:
            already_processed.add('CantidadAduana')
            try:
                self.CantidadAduana = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (CantidadAduana): %s' % exp)
        value = find_attr_value_('UnidadAduana', node)
        if value is not None and 'UnidadAduana' not in already_processed:
            already_processed.add('UnidadAduana')
            self.UnidadAduana = value
        value = find_attr_value_('ValorUnitarioAduana', node)
        if value is not None and 'ValorUnitarioAduana' not in already_processed:
            already_processed.add('ValorUnitarioAduana')
            try:
                self.ValorUnitarioAduana = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ValorUnitarioAduana): %s' % exp)
        value = find_attr_value_('ValorDolares', node)
        if value is not None and 'ValorDolares' not in already_processed:
            already_processed.add('ValorDolares')
            try:
                self.ValorDolares = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ValorDolares): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DescripcionesEspecificas':
            obj_ = DescripcionesEspecificasType.factory()
            obj_.build(child_)
            self.DescripcionesEspecificas.append(obj_)
            obj_.original_tagname_ = 'DescripcionesEspecificas'
# end class MercanciaType


class DescripcionesEspecificasType(GeneratedsSuper):
    """Atributo requerido que indica la marca de la mercancía.Atributo
    opcional que indica el modelo de la mercancía.Atributo opcional
    que indica el submodelo de la mercancía.Atributo opcional que
    indica el número de serie de la mercancía."""
    subclass = None
    superclass = None
    def __init__(self, Marca=None, Modelo=None, SubModelo=None, NumeroSerie=None):
        self.original_tagname_ = None
        self.Marca = _cast(None, Marca)
        self.Modelo = _cast(None, Modelo)
        self.SubModelo = _cast(None, SubModelo)
        self.NumeroSerie = _cast(None, NumeroSerie)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DescripcionesEspecificasType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DescripcionesEspecificasType.subclass:
            return DescripcionesEspecificasType.subclass(*args_, **kwargs_)
        else:
            return DescripcionesEspecificasType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Marca(self): return self.Marca
    def set_Marca(self, Marca): self.Marca = Marca
    def get_Modelo(self): return self.Modelo
    def set_Modelo(self, Modelo): self.Modelo = Modelo
    def get_SubModelo(self): return self.SubModelo
    def set_SubModelo(self, SubModelo): self.SubModelo = SubModelo
    def get_NumeroSerie(self): return self.NumeroSerie
    def set_NumeroSerie(self, NumeroSerie): self.NumeroSerie = NumeroSerie
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='DescripcionesEspecificasType', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DescripcionesEspecificasType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='DescripcionesEspecificasType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='DescripcionesEspecificasType'):
        if self.Marca is not None and 'Marca' not in already_processed:
            already_processed.add('Marca')
            outfile.write(' Marca=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Marca), input_name='Marca')), ))
        if self.Modelo is not None and 'Modelo' not in already_processed:
            already_processed.add('Modelo')
            outfile.write(' Modelo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Modelo), input_name='Modelo')), ))
        if self.SubModelo is not None and 'SubModelo' not in already_processed:
            already_processed.add('SubModelo')
            outfile.write(' SubModelo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.SubModelo), input_name='SubModelo')), ))
        if self.NumeroSerie is not None and 'NumeroSerie' not in already_processed:
            already_processed.add('NumeroSerie')
            outfile.write(' NumeroSerie=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumeroSerie), input_name='NumeroSerie')), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='DescripcionesEspecificasType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Marca', node)
        if value is not None and 'Marca' not in already_processed:
            already_processed.add('Marca')
            self.Marca = value
        value = find_attr_value_('Modelo', node)
        if value is not None and 'Modelo' not in already_processed:
            already_processed.add('Modelo')
            self.Modelo = value
        value = find_attr_value_('SubModelo', node)
        if value is not None and 'SubModelo' not in already_processed:
            already_processed.add('SubModelo')
            self.SubModelo = value
        value = find_attr_value_('NumeroSerie', node)
        if value is not None and 'NumeroSerie' not in already_processed:
            already_processed.add('NumeroSerie')
            self.NumeroSerie = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DescripcionesEspecificasType


class PagoType(GeneratedsSuper):
    """Atributo requerido para expresar la fecha y hora en la que el
    beneficiario recibe el pago. Se expresa en la forma aaaa-mm-
    ddThh:mm:ss, de acuerdo con la especificación ISO 8601.En caso
    de no contar con la hora se debe registrar 12:00:00.Atributo
    requerido para expresar la clave de la forma en que se realiza
    el pago.Atributo requerido para identificar la clave de la
    moneda utilizada para realizar el pago, cuando se usa moneda
    nacional se registra MXN. El atributo Pagos:Pago:Monto y los
    atributos TotalImpuestosRetenidos, TotalImpuestosTrasladados,
    Traslados:Traslado:Importe y Retenciones:Retencion:Importe del
    nodo Pago:Impuestos deben ser expresados en esta moneda.
    Conforme con la especificación ISO 4217.Atributo condicional
    para expresar el tipo de cambio de la moneda a la fecha en que
    se realizó el pago. El valor debe reflejar el número de pesos
    mexicanos que equivalen a una unidad de la divisa señalada en el
    atributo MonedaP. Es requerido cuando el atributo MonedaP es
    diferente a MXN.Atributo requerido para expresar el importe del
    pago.Atributo condicional para expresar el número de cheque,
    número de autorización, número de referencia, clave de rastreo
    en caso de ser SPEI, línea de captura o algún número de
    referencia análogo que identifique la operación que ampara el
    pago efectuadoAtributo condicional para expresar la clave RFC de
    la entidad emisora de la cuenta origen, es decir, la operadora,
    el banco, la institución financiera, emisor de monedero
    electrónico, etc., en caso de ser extranjero colocar
    XEXX010101000, considerar las reglas de obligatoriedad
    publicadas en la página del SAT para éste atributo de acuerdo
    con el catálogo catCFDI:c_FormaPago.Atributo condicional para
    expresar el nombre del banco ordenante, es requerido en caso de
    ser extranjero. Considerar las reglas de obligatoriedad
    publicadas en la página del SAT para éste atributo de acuerdo
    con el catálogo catCFDI:c_FormaPago.Atributo condicional para
    incorporar el número de la cuenta con la que se realizó el pago.
    Considerar las reglas de obligatoriedad publicadas en la página
    del SAT para éste atributo de acuerdo con el catálogo
    catCFDI:c_FormaPagoAtributo condicional para expresar la clave
    RFC de la entidad operadora de la cuenta destino, es decir, la
    operadora, el banco, la institución financiera, emisor de
    monedero electrónico, etc. Considerar las reglas de
    obligatoriedad publicadas en la página del SAT para éste
    atributo de acuerdo con el catálogo catCFDI:c_FormaPago.Atributo
    condicional para incorporar el número de cuenta en donde se
    recibió el pago. Considerar las reglas de obligatoriedad
    publicadas en la página del SAT para éste atributo de acuerdo
    con el catálogo catCFDI:c_FormaPago.Atributo condicional para
    identificar la clave del tipo de cadena de pago que genera la
    entidad receptora del pago. Considerar las reglas de
    obligatoriedad publicadas en la página del SAT para éste
    atributo de acuerdo con el catálogo catCFDI:c_FormaPago.Atributo
    condicional que sirve para incorporar el certificado que ampara
    al pago, como una cadena de texto en formato base 64. Es
    requerido en caso de que el atributo TipoCadPago contenga
    información.Atributo condicional para expresar la cadena
    original del comprobante de pago generado por la entidad emisora
    de la cuenta beneficiaria. Es requerido en caso de que el
    atributo TipoCadPago contenga información.Atributo condicional
    para integrar el sello digital que se asocie al pago. La entidad
    que emite el comprobante de pago, ingresa una cadena original y
    el sello digital en una sección de dicho comprobante, este sello
    digital es el que se debe registrar en este campo. Debe ser
    expresado como una cadena de texto en formato base 64. Es
    requerido en caso de que el atributo TipoCadPago contenga
    información."""
    subclass = None
    superclass = None
    def __init__(self, FechaPago=None, FormaDePagoP=None, MonedaP=None, TipoCambioP=None, Monto=None, NumOperacion=None, RfcEmisorCtaOrd=None, NomBancoOrdExt=None, CtaOrdenante=None, RfcEmisorCtaBen=None, CtaBeneficiario=None, TipoCadPago=None, CertPago=None, CadPago=None, SelloPago=None, DoctoRelacionado=None, Impuestos=None):
        self.original_tagname_ = None
        self.FechaPago = _cast(None, FechaPago)
        self.FormaDePagoP = _cast(None, FormaDePagoP)
        self.MonedaP = _cast(None, MonedaP)
        #self.TipoCambioP = _cast(float, TipoCambioP)
        self.TipoCambioP = _cast(None, TipoCambioP)
        self.Monto = _cast(None, Monto)
        self.NumOperacion = _cast(None, NumOperacion)
        self.RfcEmisorCtaOrd = _cast(None, RfcEmisorCtaOrd)
        self.NomBancoOrdExt = _cast(None, NomBancoOrdExt)
        self.CtaOrdenante = _cast(None, CtaOrdenante)
        self.RfcEmisorCtaBen = _cast(None, RfcEmisorCtaBen)
        self.CtaBeneficiario = _cast(None, CtaBeneficiario)
        self.TipoCadPago = _cast(None, TipoCadPago)
        self.CertPago = _cast(None, CertPago)
        self.CadPago = _cast(None, CadPago)
        self.SelloPago = _cast(None, SelloPago)
        if DoctoRelacionado is None:
            self.DoctoRelacionado = []
        else:
            self.DoctoRelacionado = DoctoRelacionado
        if Impuestos is None:
            self.Impuestos = []
        else:
            self.Impuestos = Impuestos
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PagoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PagoType.subclass:
            return PagoType.subclass(*args_, **kwargs_)
        else:
            return PagoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DoctoRelacionado(self): return self.DoctoRelacionado
    def set_DoctoRelacionado(self, DoctoRelacionado): self.DoctoRelacionado = DoctoRelacionado
    def add_DoctoRelacionado(self, value): self.DoctoRelacionado.append(value)
    def insert_DoctoRelacionado_at(self, index, value): self.DoctoRelacionado.insert(index, value)
    def replace_DoctoRelacionado_at(self, index, value): self.DoctoRelacionado[index] = value
    def get_Impuestos(self): return self.Impuestos
    def set_Impuestos(self, Impuestos): self.Impuestos = Impuestos
    def add_Impuestos(self, value): self.Impuestos.append(value)
    def insert_Impuestos_at(self, index, value): self.Impuestos.insert(index, value)
    def replace_Impuestos_at(self, index, value): self.Impuestos[index] = value
    def get_FechaPago(self): return self.FechaPago
    def set_FechaPago(self, FechaPago): self.FechaPago = FechaPago
    def get_FormaDePagoP(self): return self.FormaDePagoP
    def set_FormaDePagoP(self, FormaDePagoP): self.FormaDePagoP = FormaDePagoP
    def get_MonedaP(self): return self.MonedaP
    def set_MonedaP(self, MonedaP): self.MonedaP = MonedaP
    def get_TipoCambioP(self): return self.TipoCambioP
    def set_TipoCambioP(self, TipoCambioP): self.TipoCambioP = TipoCambioP
    def get_Monto(self): return self.Monto
    def set_Monto(self, Monto): self.Monto = Monto
    def get_NumOperacion(self): return self.NumOperacion
    def set_NumOperacion(self, NumOperacion): self.NumOperacion = NumOperacion
    def get_RfcEmisorCtaOrd(self): return self.RfcEmisorCtaOrd
    def set_RfcEmisorCtaOrd(self, RfcEmisorCtaOrd): self.RfcEmisorCtaOrd = RfcEmisorCtaOrd
    def get_NomBancoOrdExt(self): return self.NomBancoOrdExt
    def set_NomBancoOrdExt(self, NomBancoOrdExt): self.NomBancoOrdExt = NomBancoOrdExt
    def get_CtaOrdenante(self): return self.CtaOrdenante
    def set_CtaOrdenante(self, CtaOrdenante): self.CtaOrdenante = CtaOrdenante
    def get_RfcEmisorCtaBen(self): return self.RfcEmisorCtaBen
    def set_RfcEmisorCtaBen(self, RfcEmisorCtaBen): self.RfcEmisorCtaBen = RfcEmisorCtaBen
    def get_CtaBeneficiario(self): return self.CtaBeneficiario
    def set_CtaBeneficiario(self, CtaBeneficiario): self.CtaBeneficiario = CtaBeneficiario
    def get_TipoCadPago(self): return self.TipoCadPago
    def set_TipoCadPago(self, TipoCadPago): self.TipoCadPago = TipoCadPago
    def get_CertPago(self): return self.CertPago
    def set_CertPago(self, CertPago): self.CertPago = CertPago
    def get_CadPago(self): return self.CadPago
    def set_CadPago(self, CadPago): self.CadPago = CadPago
    def get_SelloPago(self): return self.SelloPago
    def set_SelloPago(self, SelloPago): self.SelloPago = SelloPago
    def hasContent_(self):
        if (
            self.DoctoRelacionado or
            self.Impuestos
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pago10:', name_='PagoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PagoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pago10:', name_='PagoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pago10:', name_='PagoType'):
        if self.FechaPago is not None and 'FechaPago' not in already_processed:
            already_processed.add('FechaPago')
            outfile.write(' FechaPago=%s' % (quote_attrib(self.FechaPago), ))
        if self.FormaDePagoP is not None and 'FormaDePagoP' not in already_processed:
            already_processed.add('FormaDePagoP')
            outfile.write(' FormaDePagoP=%s' % (quote_attrib(self.FormaDePagoP), ))
        if self.MonedaP is not None and 'MonedaP' not in already_processed:
            already_processed.add('MonedaP')
            outfile.write(' MonedaP=%s' % (quote_attrib(self.MonedaP), ))
        if self.TipoCambioP is not None and 'TipoCambioP' not in already_processed:
            already_processed.add('TipoCambioP')
            #outfile.write(' TipoCambioP="%s"' % self.gds_format_float(self.TipoCambioP, input_name='TipoCambioP'))
            outfile.write(' TipoCambioP="%s"' % self.TipoCambioP)
        if self.Monto is not None and 'Monto' not in already_processed:
            already_processed.add('Monto')
            outfile.write(' Monto=%s' % (quote_attrib(self.Monto), ))
        if self.NumOperacion is not None and 'NumOperacion' not in already_processed:
            already_processed.add('NumOperacion')
            outfile.write(' NumOperacion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumOperacion), input_name='NumOperacion')), ))
        if self.RfcEmisorCtaOrd is not None and 'RfcEmisorCtaOrd' not in already_processed:
            already_processed.add('RfcEmisorCtaOrd')
            outfile.write(' RfcEmisorCtaOrd=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.RfcEmisorCtaOrd), input_name='RfcEmisorCtaOrd')), ))
        if self.NomBancoOrdExt is not None and 'NomBancoOrdExt' not in already_processed:
            already_processed.add('NomBancoOrdExt')
            outfile.write(' NomBancoOrdExt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NomBancoOrdExt), input_name='NomBancoOrdExt')), ))
        if self.CtaOrdenante is not None and 'CtaOrdenante' not in already_processed:
            already_processed.add('CtaOrdenante')
            outfile.write(' CtaOrdenante=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CtaOrdenante), input_name='CtaOrdenante')), ))
        if self.RfcEmisorCtaBen is not None and 'RfcEmisorCtaBen' not in already_processed:
            already_processed.add('RfcEmisorCtaBen')
            outfile.write(' RfcEmisorCtaBen=%s' % (quote_attrib(self.RfcEmisorCtaBen), ))
        if self.CtaBeneficiario is not None and 'CtaBeneficiario' not in already_processed:
            already_processed.add('CtaBeneficiario')
            outfile.write(' CtaBeneficiario=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CtaBeneficiario), input_name='CtaBeneficiario')), ))
        if self.TipoCadPago is not None and 'TipoCadPago' not in already_processed:
            already_processed.add('TipoCadPago')
            outfile.write(' TipoCadPago=%s' % (quote_attrib(self.TipoCadPago), ))
        if self.CertPago is not None and 'CertPago' not in already_processed:
            already_processed.add('CertPago')
            outfile.write(' CertPago=%s' % (quote_attrib(self.CertPago), ))
        if self.CadPago is not None and 'CadPago' not in already_processed:
            already_processed.add('CadPago')
            outfile.write(' CadPago=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.CadPago), input_name='CadPago')), ))
        if self.SelloPago is not None and 'SelloPago' not in already_processed:
            already_processed.add('SelloPago')
            outfile.write(' SelloPago=%s' % (quote_attrib(self.SelloPago), ))
    def exportChildren(self, outfile, level, namespace_='pago10:', name_='PagoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DoctoRelacionado_ in self.DoctoRelacionado:
            DoctoRelacionado_.export(outfile, level, namespace_, name_='DoctoRelacionado', pretty_print=pretty_print)
        for Impuestos_ in self.Impuestos:
            Impuestos_.export(outfile, level, namespace_, name_='Impuestos', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('FechaPago', node)
        if value is not None and 'FechaPago' not in already_processed:
            already_processed.add('FechaPago')
            self.FechaPago = value
        value = find_attr_value_('FormaDePagoP', node)
        if value is not None and 'FormaDePagoP' not in already_processed:
            already_processed.add('FormaDePagoP')
            self.FormaDePagoP = value
        value = find_attr_value_('MonedaP', node)
        if value is not None and 'MonedaP' not in already_processed:
            already_processed.add('MonedaP')
            self.MonedaP = value
        value = find_attr_value_('TipoCambioP', node)
        if value is not None and 'TipoCambioP' not in already_processed:
            already_processed.add('TipoCambioP')
            try:
                self.TipoCambioP = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (TipoCambioP): %s' % exp)
        value = find_attr_value_('Monto', node)
        if value is not None and 'Monto' not in already_processed:
            already_processed.add('Monto')
            self.Monto = value
        value = find_attr_value_('NumOperacion', node)
        if value is not None and 'NumOperacion' not in already_processed:
            already_processed.add('NumOperacion')
            self.NumOperacion = value
        value = find_attr_value_('RfcEmisorCtaOrd', node)
        if value is not None and 'RfcEmisorCtaOrd' not in already_processed:
            already_processed.add('RfcEmisorCtaOrd')
            self.RfcEmisorCtaOrd = value
        value = find_attr_value_('NomBancoOrdExt', node)
        if value is not None and 'NomBancoOrdExt' not in already_processed:
            already_processed.add('NomBancoOrdExt')
            self.NomBancoOrdExt = value
        value = find_attr_value_('CtaOrdenante', node)
        if value is not None and 'CtaOrdenante' not in already_processed:
            already_processed.add('CtaOrdenante')
            self.CtaOrdenante = value
        value = find_attr_value_('RfcEmisorCtaBen', node)
        if value is not None and 'RfcEmisorCtaBen' not in already_processed:
            already_processed.add('RfcEmisorCtaBen')
            self.RfcEmisorCtaBen = value
        value = find_attr_value_('CtaBeneficiario', node)
        if value is not None and 'CtaBeneficiario' not in already_processed:
            already_processed.add('CtaBeneficiario')
            self.CtaBeneficiario = value
        value = find_attr_value_('TipoCadPago', node)
        if value is not None and 'TipoCadPago' not in already_processed:
            already_processed.add('TipoCadPago')
            self.TipoCadPago = value
        value = find_attr_value_('CertPago', node)
        if value is not None and 'CertPago' not in already_processed:
            already_processed.add('CertPago')
            self.CertPago = value
        value = find_attr_value_('CadPago', node)
        if value is not None and 'CadPago' not in already_processed:
            already_processed.add('CadPago')
            self.CadPago = value
        value = find_attr_value_('SelloPago', node)
        if value is not None and 'SelloPago' not in already_processed:
            already_processed.add('SelloPago')
            self.SelloPago = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DoctoRelacionado':
            obj_ = DoctoRelacionadoType.factory()
            obj_.build(child_)
            self.DoctoRelacionado.append(obj_)
            obj_.original_tagname_ = 'DoctoRelacionado'
        elif nodeName_ == 'Impuestos':
            obj_ = ImpuestosType11.factory()
            obj_.build(child_)
            self.Impuestos.append(obj_)
            obj_.original_tagname_ = 'Impuestos'
# end class PagoType


class DoctoRelacionadoType(GeneratedsSuper):
    """Atributo requerido para expresar el identificador del documento
    relacionado con el pago. Este dato puede ser un Folio Fiscal de
    la Factura Electrónica o bien el número de operación de un
    documento digital.Atributo opcional para precisar la serie del
    comprobante para control interno del contribuyente, acepta una
    cadena de caracteres.Atributo opcional para precisar el folio
    del comprobante para control interno del contribuyente, acepta
    una cadena de caracteres.Atributo requerido para identificar la
    clave de la moneda utilizada en los importes del documento
    relacionado, cuando se usa moneda nacional o el documento
    relacionado no especifica la moneda se registra MXN. Los
    importes registrados en los atributos “SaldoAnterior”,
    “ImportePagado” e “ImporteSaldoInsoluto” de éste nodo, deben
    corresponder a esta moneda. Conforme con la especificación ISO
    4217.Atributo condicional para expresar el tipo de cambio
    conforme con la moneda registrada en el documento relacionado.
    Es requerido cuando la moneda del documento relacionado es
    distinta de la moneda de pago. Se debe registrar el número de
    unidades de la moneda señalada en el documento relacionado que
    equivalen a una unidad de la moneda del pago. Por ejemplo: El
    documento relacionado se registra en USD El pago se realiza por
    100 EUR. Este atributo se registra como 1.114700 USD/EUR. El
    importe pagado equivale a 100 EUR * 1.114700 USD/EUR = 111.47
    USD.Atributo requerido para expresar la clave del método de pago
    que se registró en el documento relacionado.Atributo condicional
    para expresar el número de parcialidad que corresponde al pago.
    Es requerido cuando MetodoDePagoDR contiene: “Pago en
    parcialidades o diferido” o “Pago inicial y
    parcialidades”.Atributo condicional para expresar el importe del
    saldo anterior del documento relacionado o el monto del saldo
    insoluto de la parcialidad anterior. Es requerido cuando
    MetodoDePagoDR contiene: “Pago en parcialidades o diferido” o
    “Pago inicial y parcialidades” En el caso de que sea la primer
    parcialidad este campo debe contener el importe total del
    documento relacionado.Atributo condicional para expresar el
    importe pagado para el documento relacionado. Es obligatorio
    cuando exista más de un documento relacionado o cuando existe un
    documento relacionado y el TipoCambioDR tiene un valor.Atributo
    condicional para expresar la diferencia entre el importe del
    saldo anterior y el monto del pago. Es requerido cuando
    MetodoDePagoDR contiene: “Pago en parcialidades o diferido” o
    “Pago inicial y parcialidades”."""
    subclass = None
    superclass = None
    def __init__(self, IdDocumento=None, Serie=None, Folio=None, MonedaDR=None, TipoCambioDR=None, MetodoDePagoDR=None, NumParcialidad=None, ImpSaldoAnt=None, ImpPagado=None, ImpSaldoInsoluto=None):
        self.original_tagname_ = None
        self.IdDocumento = _cast(None, IdDocumento)
        self.Serie = _cast(None, Serie)
        self.Folio = _cast(None, Folio)
        self.MonedaDR = _cast(None, MonedaDR)
        #self.TipoCambioDR = _cast(float, TipoCambioDR)
        self.TipoCambioDR = _cast(None, TipoCambioDR)
        self.MetodoDePagoDR = _cast(None, MetodoDePagoDR)
        #self.NumParcialidad = _cast(int, NumParcialidad)
        self.NumParcialidad = _cast(None, NumParcialidad)
        self.ImpSaldoAnt = _cast(None, ImpSaldoAnt)
        self.ImpPagado = _cast(None, ImpPagado)
        self.ImpSaldoInsoluto = _cast(None, ImpSaldoInsoluto)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoctoRelacionadoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoctoRelacionadoType.subclass:
            return DoctoRelacionadoType.subclass(*args_, **kwargs_)
        else:
            return DoctoRelacionadoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IdDocumento(self): return self.IdDocumento
    def set_IdDocumento(self, IdDocumento): self.IdDocumento = IdDocumento
    def get_Serie(self): return self.Serie
    def set_Serie(self, Serie): self.Serie = Serie
    def get_Folio(self): return self.Folio
    def set_Folio(self, Folio): self.Folio = Folio
    def get_MonedaDR(self): return self.MonedaDR
    def set_MonedaDR(self, MonedaDR): self.MonedaDR = MonedaDR
    def get_TipoCambioDR(self): return self.TipoCambioDR
    def set_TipoCambioDR(self, TipoCambioDR): self.TipoCambioDR = TipoCambioDR
    def get_MetodoDePagoDR(self): return self.MetodoDePagoDR
    def set_MetodoDePagoDR(self, MetodoDePagoDR): self.MetodoDePagoDR = MetodoDePagoDR
    def get_NumParcialidad(self): return self.NumParcialidad
    def set_NumParcialidad(self, NumParcialidad): self.NumParcialidad = NumParcialidad
    def get_ImpSaldoAnt(self): return self.ImpSaldoAnt
    def set_ImpSaldoAnt(self, ImpSaldoAnt): self.ImpSaldoAnt = ImpSaldoAnt
    def get_ImpPagado(self): return self.ImpPagado
    def set_ImpPagado(self, ImpPagado): self.ImpPagado = ImpPagado
    def get_ImpSaldoInsoluto(self): return self.ImpSaldoInsoluto
    def set_ImpSaldoInsoluto(self, ImpSaldoInsoluto): self.ImpSaldoInsoluto = ImpSaldoInsoluto
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='pago10:', name_='DoctoRelacionadoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DoctoRelacionadoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='pago10:', name_='DoctoRelacionadoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='pago10:', name_='DoctoRelacionadoType'):
        if self.IdDocumento is not None and 'IdDocumento' not in already_processed:
            already_processed.add('IdDocumento')
            outfile.write(' IdDocumento=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.IdDocumento), input_name='IdDocumento')), ))
        if self.Serie is not None and 'Serie' not in already_processed:
            already_processed.add('Serie')
            outfile.write(' Serie=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Serie), input_name='Serie')), ))
        if self.Folio is not None and 'Folio' not in already_processed:
            already_processed.add('Folio')
            outfile.write(' Folio=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Folio), input_name='Folio')), ))
        if self.MonedaDR is not None and 'MonedaDR' not in already_processed:
            already_processed.add('MonedaDR')
            outfile.write(' MonedaDR=%s' % (quote_attrib(self.MonedaDR), ))
        if self.TipoCambioDR is not None and 'TipoCambioDR' not in already_processed:
            already_processed.add('TipoCambioDR')
            #outfile.write(' TipoCambioDR="%s"' % self.gds_format_float(self.TipoCambioDR, input_name='TipoCambioDR'))
            outfile.write(' TipoCambioDR="%s"' % self.TipoCambioDR)
        if self.MetodoDePagoDR is not None and 'MetodoDePagoDR' not in already_processed:
            already_processed.add('MetodoDePagoDR')
            outfile.write(' MetodoDePagoDR=%s' % (quote_attrib(self.MetodoDePagoDR), ))
        if self.NumParcialidad is not None and 'NumParcialidad' not in already_processed:
            already_processed.add('NumParcialidad')
            #outfile.write(' NumParcialidad="%s"' % self.gds_format_integer(self.NumParcialidad, input_name='NumParcialidad'))
            outfile.write(' NumParcialidad="%s"' % self.NumParcialidad)
        if self.ImpSaldoAnt is not None and 'ImpSaldoAnt' not in already_processed:
            already_processed.add('ImpSaldoAnt')
            outfile.write(' ImpSaldoAnt=%s' % (quote_attrib(self.ImpSaldoAnt), ))
        if self.ImpPagado is not None and 'ImpPagado' not in already_processed:
            already_processed.add('ImpPagado')
            outfile.write(' ImpPagado=%s' % (quote_attrib(self.ImpPagado), ))
        if self.ImpSaldoInsoluto is not None and 'ImpSaldoInsoluto' not in already_processed:
            already_processed.add('ImpSaldoInsoluto')
            outfile.write(' ImpSaldoInsoluto=%s' % (quote_attrib(self.ImpSaldoInsoluto), ))
    def exportChildren(self, outfile, level, namespace_='pago10:', name_='DoctoRelacionadoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('IdDocumento', node)
        if value is not None and 'IdDocumento' not in already_processed:
            already_processed.add('IdDocumento')
            self.IdDocumento = value
        value = find_attr_value_('Serie', node)
        if value is not None and 'Serie' not in already_processed:
            already_processed.add('Serie')
            self.Serie = value
        value = find_attr_value_('Folio', node)
        if value is not None and 'Folio' not in already_processed:
            already_processed.add('Folio')
            self.Folio = value
        value = find_attr_value_('MonedaDR', node)
        if value is not None and 'MonedaDR' not in already_processed:
            already_processed.add('MonedaDR')
            self.MonedaDR = value
        value = find_attr_value_('TipoCambioDR', node)
        if value is not None and 'TipoCambioDR' not in already_processed:
            already_processed.add('TipoCambioDR')
            try:
                self.TipoCambioDR = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (TipoCambioDR): %s' % exp)
        value = find_attr_value_('MetodoDePagoDR', node)
        if value is not None and 'MetodoDePagoDR' not in already_processed:
            already_processed.add('MetodoDePagoDR')
            self.MetodoDePagoDR = value
        value = find_attr_value_('NumParcialidad', node)
        if value is not None and 'NumParcialidad' not in already_processed:
            already_processed.add('NumParcialidad')
            try:
                self.NumParcialidad = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ImpSaldoAnt', node)
        if value is not None and 'ImpSaldoAnt' not in already_processed:
            already_processed.add('ImpSaldoAnt')
            self.ImpSaldoAnt = value
        value = find_attr_value_('ImpPagado', node)
        if value is not None and 'ImpPagado' not in already_processed:
            already_processed.add('ImpPagado')
            self.ImpPagado = value
        value = find_attr_value_('ImpSaldoInsoluto', node)
        if value is not None and 'ImpSaldoInsoluto' not in already_processed:
            already_processed.add('ImpSaldoInsoluto')
            self.ImpSaldoInsoluto = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DoctoRelacionadoType


class ImpuestosType11(GeneratedsSuper):
    """Atributo condicional para expresar el total de los impuestos
    retenidos que se desprenden del pago. No se permiten valores
    negativos.Atributo condicional para expresar el total de los
    impuestos trasladados que se desprenden del pago. No se permiten
    valores negativos."""
    subclass = None
    superclass = None
    def __init__(self, TotalImpuestosRetenidos=None, TotalImpuestosTrasladados=None, Retenciones=None, Traslados=None):
        self.original_tagname_ = None
        self.TotalImpuestosRetenidos = _cast(None, TotalImpuestosRetenidos)
        self.TotalImpuestosTrasladados = _cast(None, TotalImpuestosTrasladados)
        self.Retenciones = Retenciones
        self.Traslados = Traslados
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ImpuestosType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ImpuestosType11.subclass:
            return ImpuestosType11.subclass(*args_, **kwargs_)
        else:
            return ImpuestosType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Retenciones(self): return self.Retenciones
    def set_Retenciones(self, Retenciones): self.Retenciones = Retenciones
    def get_Traslados(self): return self.Traslados
    def set_Traslados(self, Traslados): self.Traslados = Traslados
    def get_TotalImpuestosRetenidos(self): return self.TotalImpuestosRetenidos
    def set_TotalImpuestosRetenidos(self, TotalImpuestosRetenidos): self.TotalImpuestosRetenidos = TotalImpuestosRetenidos
    def get_TotalImpuestosTrasladados(self): return self.TotalImpuestosTrasladados
    def set_TotalImpuestosTrasladados(self, TotalImpuestosTrasladados): self.TotalImpuestosTrasladados = TotalImpuestosTrasladados
    def hasContent_(self):
        if (
            self.Retenciones is not None or
            self.Traslados is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='ImpuestosType11', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ImpuestosType11')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='ImpuestosType11', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='ImpuestosType11'):
        if self.TotalImpuestosRetenidos is not None and 'TotalImpuestosRetenidos' not in already_processed:
            already_processed.add('TotalImpuestosRetenidos')
            outfile.write(' TotalImpuestosRetenidos=%s' % (quote_attrib(self.TotalImpuestosRetenidos), ))
        if self.TotalImpuestosTrasladados is not None and 'TotalImpuestosTrasladados' not in already_processed:
            already_processed.add('TotalImpuestosTrasladados')
            outfile.write(' TotalImpuestosTrasladados=%s' % (quote_attrib(self.TotalImpuestosTrasladados), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='ImpuestosType11', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Retenciones is not None:
            self.Retenciones.export(outfile, level, namespace_, name_='Retenciones', pretty_print=pretty_print)
        if self.Traslados is not None:
            self.Traslados.export(outfile, level, namespace_, name_='Traslados', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TotalImpuestosRetenidos', node)
        if value is not None and 'TotalImpuestosRetenidos' not in already_processed:
            already_processed.add('TotalImpuestosRetenidos')
            self.TotalImpuestosRetenidos = value
        value = find_attr_value_('TotalImpuestosTrasladados', node)
        if value is not None and 'TotalImpuestosTrasladados' not in already_processed:
            already_processed.add('TotalImpuestosTrasladados')
            self.TotalImpuestosTrasladados = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Retenciones':
            obj_ = RetencionesType12.factory()
            obj_.build(child_)
            self.Retenciones = obj_
            obj_.original_tagname_ = 'Retenciones'
        elif nodeName_ == 'Traslados':
            obj_ = TrasladosType14.factory()
            obj_.build(child_)
            self.Traslados = obj_
            obj_.original_tagname_ = 'Traslados'
# end class ImpuestosType11


class RetencionesType12(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Retencion=None):
        self.original_tagname_ = None
        if Retencion is None:
            self.Retencion = []
        else:
            self.Retencion = Retencion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetencionesType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetencionesType12.subclass:
            return RetencionesType12.subclass(*args_, **kwargs_)
        else:
            return RetencionesType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Retencion(self): return self.Retencion
    def set_Retencion(self, Retencion): self.Retencion = Retencion
    def add_Retencion(self, value): self.Retencion.append(value)
    def insert_Retencion_at(self, index, value): self.Retencion.insert(index, value)
    def replace_Retencion_at(self, index, value): self.Retencion[index] = value
    def hasContent_(self):
        if (
            self.Retencion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='RetencionesType12', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RetencionesType12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='RetencionesType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='RetencionesType12'):
        pass
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='RetencionesType12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Retencion_ in self.Retencion:
            Retencion_.export(outfile, level, namespace_, name_='Retencion', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Retencion':
            obj_ = RetencionType13.factory()
            obj_.build(child_)
            self.Retencion.append(obj_)
            obj_.original_tagname_ = 'Retencion'
# end class RetencionesType12


class RetencionType13(GeneratedsSuper):
    """Atributo requerido para señalar la clave del tipo de impuesto
    retenido.Atributo requerido para señalar el importe o monto del
    impuesto retenido. No se permiten valores negativos."""
    subclass = None
    superclass = None
    def __init__(self, Impuesto=None, Importe=None):
        self.original_tagname_ = None
        self.Impuesto = _cast(None, Impuesto)
        self.Importe = _cast(None, Importe)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RetencionType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RetencionType13.subclass:
            return RetencionType13.subclass(*args_, **kwargs_)
        else:
            return RetencionType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Impuesto(self): return self.Impuesto
    def set_Impuesto(self, Impuesto): self.Impuesto = Impuesto
    def get_Importe(self): return self.Importe
    def set_Importe(self, Importe): self.Importe = Importe
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='RetencionType13', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RetencionType13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='RetencionType13', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='RetencionType13'):
        if self.Impuesto is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            outfile.write(' Impuesto=%s' % (quote_attrib(self.Impuesto), ))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe=%s' % (quote_attrib(self.Importe), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='RetencionType13', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Impuesto', node)
        if value is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            self.Impuesto = value
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            self.Importe = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RetencionType13


class TrasladosType14(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Traslado=None):
        self.original_tagname_ = None
        if Traslado is None:
            self.Traslado = []
        else:
            self.Traslado = Traslado
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrasladosType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrasladosType14.subclass:
            return TrasladosType14.subclass(*args_, **kwargs_)
        else:
            return TrasladosType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Traslado(self): return self.Traslado
    def set_Traslado(self, Traslado): self.Traslado = Traslado
    def add_Traslado(self, value): self.Traslado.append(value)
    def insert_Traslado_at(self, index, value): self.Traslado.insert(index, value)
    def replace_Traslado_at(self, index, value): self.Traslado[index] = value
    def hasContent_(self):
        if (
            self.Traslado
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='TrasladosType14', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrasladosType14')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='TrasladosType14', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='TrasladosType14'):
        pass
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='TrasladosType14', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Traslado_ in self.Traslado:
            Traslado_.export(outfile, level, namespace_, name_='Traslado', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Traslado':
            obj_ = TrasladoType15.factory()
            obj_.build(child_)
            self.Traslado.append(obj_)
            obj_.original_tagname_ = 'Traslado'
# end class TrasladosType14


class TrasladoType15(GeneratedsSuper):
    """Atributo requerido para señalar la clave del tipo de impuesto
    trasladado.Atributo requerido para señalar la clave del tipo de
    factor que se aplica a la base del impuesto.Atributo requerido
    para señalar la clave de la tasa o cuota del impuesto que se
    traslada.Atributo requerido para señalar el importe del impuesto
    trasladado. No se permiten valores negativos."""
    subclass = None
    superclass = None
    def __init__(self, Impuesto=None, TipoFactor=None, TasaOCuota=None, Importe=None):
        self.original_tagname_ = None
        self.Impuesto = _cast(None, Impuesto)
        self.TipoFactor = _cast(None, TipoFactor)
        self.TasaOCuota = _cast(None, TasaOCuota)
        self.Importe = _cast(None, Importe)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TrasladoType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TrasladoType15.subclass:
            return TrasladoType15.subclass(*args_, **kwargs_)
        else:
            return TrasladoType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Impuesto(self): return self.Impuesto
    def set_Impuesto(self, Impuesto): self.Impuesto = Impuesto
    def get_TipoFactor(self): return self.TipoFactor
    def set_TipoFactor(self, TipoFactor): self.TipoFactor = TipoFactor
    def get_TasaOCuota(self): return self.TasaOCuota
    def set_TasaOCuota(self, TasaOCuota): self.TasaOCuota = TasaOCuota
    def get_Importe(self): return self.Importe
    def set_Importe(self, Importe): self.Importe = Importe
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='cfdi:', name_='TrasladoType15', namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TrasladoType15')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='cfdi:', name_='TrasladoType15', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='cfdi:', name_='TrasladoType15'):
        if self.Impuesto is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            outfile.write(' Impuesto=%s' % (quote_attrib(self.Impuesto), ))
        if self.TipoFactor is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            outfile.write(' TipoFactor=%s' % (quote_attrib(self.TipoFactor), ))
        if self.TasaOCuota is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            outfile.write(' TasaOCuota=%s' % (quote_attrib(self.TasaOCuota), ))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe=%s' % (quote_attrib(self.Importe), ))
    def exportChildren(self, outfile, level, namespace_='cfdi:', name_='TrasladoType15', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Impuesto', node)
        if value is not None and 'Impuesto' not in already_processed:
            already_processed.add('Impuesto')
            self.Impuesto = value
        value = find_attr_value_('TipoFactor', node)
        if value is not None and 'TipoFactor' not in already_processed:
            already_processed.add('TipoFactor')
            self.TipoFactor = value
        value = find_attr_value_('TasaOCuota', node)
        if value is not None and 'TasaOCuota' not in already_processed:
            already_processed.add('TasaOCuota')
            self.TasaOCuota = value
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            self.Importe = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TrasladoType15


GDSClassesMapping = {
    'Addenda': AddendaType,
    'CfdiRelacionado': CfdiRelacionadoType,
    'CfdiRelacionados': CfdiRelacionadosType,
    'Complemento': ComplementoType,
    'ComplementoConcepto': ComplementoConceptoType,
    'Concepto': ConceptoType,
    'Conceptos': ConceptosType,
    'CuentaPredial': CuentaPredialType,
    'DescripcionesEspecificas': DescripcionesEspecificasType,
    'Destinatario': DestinatarioType,
    'DoctoRelacionado': DoctoRelacionadoType,
    'Domicilio': DomicilioType10,
    'Emisor': EmisorType7,
    'Impuestos': ImpuestosType11,
    'InformacionAduanera': InformacionAduaneraType1,
    'Mercancia': MercanciaType,
    'Mercancias': MercanciasType,
    'Pago': PagoType,
    'Parte': ParteType,
    'Propietario': PropietarioType,
    'Receptor': ReceptorType8,
    'Retencion': RetencionType13,
    'Retenciones': RetencionesType12,
    'Traslado': TrasladoType15,
    'Traslados': TrasladosType14,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Comprobante'
        rootClass = Comprobante
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Comprobante'
        rootClass = Comprobante
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Comprobante'
        rootClass = Comprobante
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:cfdi="http://www.sat.gob.mx/cfd/3"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Comprobante'
        rootClass = Comprobante
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from CFDI_33_comp import *\n\n')
        sys.stdout.write('import CFDI_33_comp as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AddendaType",
    "CfdiRelacionadoType",
    "CfdiRelacionadosType",
    "ComercioExterior",
    "ComplementoConceptoType",
    "ComplementoType",
    "Comprobante",
    "ConceptoType",
    "ConceptosType",
    "CuentaPredialType",
    "DescripcionesEspecificasType",
    "DestinatarioType",
    "DoctoRelacionadoType",
    "DomicilioType",
    "DomicilioType10",
    "DomicilioType9",
    "EmisorType",
    "EmisorType7",
    "ImpuestosType",
    "ImpuestosType11",
    "ImpuestosType2",
    "InformacionAduaneraType",
    "InformacionAduaneraType1",
    "MercanciaType",
    "MercanciasType",
    "PagoType",
    "Pagos",
    "ParteType",
    "PropietarioType",
    "ReceptorType",
    "ReceptorType8",
    "RetencionType",
    "RetencionType13",
    "RetencionType4",
    "RetencionesType",
    "RetencionesType12",
    "RetencionesType3",
    "TrasladoType",
    "TrasladoType15",
    "TrasladoType6",
    "TrasladosType",
    "TrasladosType14",
    "TrasladosType5"
]
