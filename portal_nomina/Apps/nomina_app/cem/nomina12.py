

"""**Additional information:** 
https://github.com/ricksladkey/generateDS/blob/master/tutorial/generateds_tutoriala.txt

- If you plan to work through this tutorial, you may find it helpful
  to look at the sample code that accompanies this tutorial.  You
  can find it in the distribution under::

      tutorial/
      tutorial/Code/

- You can find additional information about ``generateDS.py`` here:

      http://www.rexx.com/~dkuhlman/generateDS.html

  That documentation is also included in the distribution.


``generateDS.py`` generates Python data structures (for example,
class definitions) from an XML schema document. These data
structures represent the elements in an XML document described by
the XML schema.  ``generateDS.py`` also generates parsers that load
an XML document into those data structures. In addition, a separate
file containing subclasses (stubs) is optionally generated. The user
can add methods to the subclasses in order to process the contents
of an XML document.
"""




import sys
import imp

import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_

imp.reload(sys)
sys.getdefaultencoding()

Validate_simpletypes_ = True
if sys.version_info.major == 3:
    BaseStrType_ = str



def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_format_porcentaje_float(self, input_data, input_name=''):
            return ('%.3f' % input_data)
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result

    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'UTF-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name, pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0, optional=0):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Nomina(GeneratedsSuper):
    """Complemento para incorporar al Comprobante Fiscal Digital por
    Internet (CFDI) la información que ampara conceptos de ingresos
    por salarios, la prestación de un servicio personal subordinado
    o conceptos asimilados a salarios (Nómina).Atributo requerido
    para la expresión de la versión del complemento.Atributo
    requerido para indicar el tipo de nómina, puede ser O= Nómina
    ordinaria o E= Nómina extraordinaria.Atributo requerido para la
    expresión de la fecha efectiva de erogación del gasto. Se
    expresa en la forma aaaa-mm-dd, de acuerdo con la especificación
    ISO 8601.Atributo requerido para la expresión de la fecha
    inicial del período de pago. Se expresa en la forma aaaa-mm-dd,
    de acuerdo con la especificación ISO 8601.Atributo requerido
    para la expresión de la fecha final del período de pago. Se
    expresa en la forma aaaa-mm-dd, de acuerdo con la especificación
    ISO 8601.Atributo requerido para la expresión del número o la
    fracción de días pagados.Atributo condicional para representar
    la suma de las percepciones.Atributo condicional para
    representar la suma de las deducciones aplicables.Atributo
    condicional para representar la suma de otros pagos."""
    subclass = None
    superclass = None
    def __init__(self, Version=None, TipoNomina=None, FechaPago=None, FechaInicialPago=None, FechaFinalPago=None, NumDiasPagados=None, TotalPercepciones=None, TotalDeducciones=None, TotalOtrosPagos=None, Emisor=None, Receptor=None, Percepciones=None, Deducciones=None, OtrosPagos=None, Incapacidades=None):
        self.original_tagname_ = None
        self.Version = _cast(None, Version)
        self.TipoNomina = _cast(None, TipoNomina)
        self.FechaPago = _cast(None, FechaPago)
        self.FechaInicialPago = _cast(None, FechaInicialPago)
        self.FechaFinalPago = _cast(None, FechaFinalPago)
        try:
            self.NumDiasPagados = _cast(None, NumDiasPagados.strip())
        except:
            self.NumDiasPagados = _cast(None, NumDiasPagados)
        self.TotalPercepciones = _cast(None, TotalPercepciones)
        self.TotalDeducciones = _cast(None, TotalDeducciones)
        self.TotalOtrosPagos = _cast(None, TotalOtrosPagos)
        self.Emisor = Emisor
        self.Receptor = Receptor
        self.Percepciones = Percepciones
        self.Deducciones = Deducciones
        self.OtrosPagos = OtrosPagos
        self.Incapacidades = Incapacidades
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Nomina)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Nomina.subclass:
            return Nomina.subclass(*args_, **kwargs_)
        else:
            return Nomina(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Emisor(self): return self.Emisor
    def set_Emisor(self, Emisor): self.Emisor = Emisor
    def get_Receptor(self): return self.Receptor
    def set_Receptor(self, Receptor): self.Receptor = Receptor
    def get_Percepciones(self): return self.Percepciones
    def set_Percepciones(self, Percepciones): self.Percepciones = Percepciones
    def get_Deducciones(self): return self.Deducciones
    def set_Deducciones(self, Deducciones): self.Deducciones = Deducciones
    def get_OtrosPagos(self): return self.OtrosPagos
    def set_OtrosPagos(self, OtrosPagos): self.OtrosPagos = OtrosPagos
    def get_Incapacidades(self): return self.Incapacidades
    def set_Incapacidades(self, Incapacidades): self.Incapacidades = Incapacidades
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_TipoNomina(self): return self.TipoNomina
    def set_TipoNomina(self, TipoNomina): self.TipoNomina = TipoNomina
    def get_FechaPago(self): return self.FechaPago
    def set_FechaPago(self, FechaPago): self.FechaPago = FechaPago
    def get_FechaInicialPago(self): return self.FechaInicialPago
    def set_FechaInicialPago(self, FechaInicialPago): self.FechaInicialPago = FechaInicialPago
    def get_FechaFinalPago(self): return self.FechaFinalPago
    def set_FechaFinalPago(self, FechaFinalPago): self.FechaFinalPago = FechaFinalPago
    def get_NumDiasPagados(self): return self.NumDiasPagados
    def set_NumDiasPagados(self, NumDiasPagados): self.NumDiasPagados = NumDiasPagados
    def get_TotalPercepciones(self): return self.TotalPercepciones
    def set_TotalPercepciones(self, TotalPercepciones): self.TotalPercepciones = TotalPercepciones
    def get_TotalDeducciones(self): return self.TotalDeducciones
    def set_TotalDeducciones(self, TotalDeducciones): self.TotalDeducciones = TotalDeducciones
    def get_TotalOtrosPagos(self): return self.TotalOtrosPagos
    def set_TotalOtrosPagos(self, TotalOtrosPagos): self.TotalOtrosPagos = TotalOtrosPagos
    def hasContent_(self):
        if (
            self.Emisor is not None or
            self.Receptor is not None or
            self.Percepciones is not None or
            self.Deducciones is not None or
            self.OtrosPagos is not None or
            self.Incapacidades is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='Nomina', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Nomina')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='Nomina', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='Nomina'):
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            outfile.write(' Version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Version), input_name='Version')), ))
        if self.TipoNomina is not None and 'TipoNomina' not in already_processed:
            already_processed.add('TipoNomina')
            outfile.write(' TipoNomina=%s' % (quote_attrib(self.TipoNomina), ))
        if self.FechaPago is not None and 'FechaPago' not in already_processed:
            already_processed.add('FechaPago')
            outfile.write(' FechaPago=%s' % (quote_attrib(self.FechaPago), ))
        if self.FechaInicialPago is not None and 'FechaInicialPago' not in already_processed:
            already_processed.add('FechaInicialPago')
            outfile.write(' FechaInicialPago=%s' % (quote_attrib(self.FechaInicialPago), ))
        if self.FechaFinalPago is not None and 'FechaFinalPago' not in already_processed:
            already_processed.add('FechaFinalPago')
            outfile.write(' FechaFinalPago=%s' % (quote_attrib(self.FechaFinalPago), ))
        if self.NumDiasPagados is not None and 'NumDiasPagados' not in already_processed:
            already_processed.add('NumDiasPagados')
            outfile.write(' NumDiasPagados="%s"' % self.gds_format_string(self.NumDiasPagados, input_name='NumDiasPagados'))
        if self.TotalPercepciones is not None and 'TotalPercepciones' not in already_processed:
            already_processed.add('TotalPercepciones')
            outfile.write(' TotalPercepciones=%s' % (quote_attrib(self.TotalPercepciones), ))
        if self.TotalDeducciones is not None and 'TotalDeducciones' not in already_processed:
            already_processed.add('TotalDeducciones')
            outfile.write(' TotalDeducciones=%s' % (quote_attrib(self.TotalDeducciones), ))
        if self.TotalOtrosPagos is not None and 'TotalOtrosPagos' not in already_processed:
            already_processed.add('TotalOtrosPagos')
            outfile.write(' TotalOtrosPagos=%s' % (quote_attrib(self.TotalOtrosPagos), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='Nomina', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Emisor is not None:
            self.Emisor.export(outfile, level, namespace_, name_='Emisor', pretty_print=pretty_print)
        if self.Receptor is not None:
            self.Receptor.export(outfile, level, namespace_, name_='Receptor', pretty_print=pretty_print)
        if self.Percepciones is not None:
            self.Percepciones.export(outfile, level, namespace_, name_='Percepciones', pretty_print=pretty_print)
        if self.Deducciones is not None:
            self.Deducciones.export(outfile, level, namespace_, name_='Deducciones', pretty_print=pretty_print)
        if self.OtrosPagos is not None:
            self.OtrosPagos.export(outfile, level, namespace_, name_='OtrosPagos', pretty_print=pretty_print)
        if self.Incapacidades is not None:
            self.Incapacidades.export(outfile, level, namespace_, name_='Incapacidades', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Version', node)
        if value is not None and 'Version' not in already_processed:
            already_processed.add('Version')
            self.Version = value
        value = find_attr_value_('TipoNomina', node)
        if value is not None and 'TipoNomina' not in already_processed:
            already_processed.add('TipoNomina')
            self.TipoNomina = value
        value = find_attr_value_('FechaPago', node)
        if value is not None and 'FechaPago' not in already_processed:
            already_processed.add('FechaPago')
            self.FechaPago = value
        value = find_attr_value_('FechaInicialPago', node)
        if value is not None and 'FechaInicialPago' not in already_processed:
            already_processed.add('FechaInicialPago')
            self.FechaInicialPago = value
        value = find_attr_value_('FechaFinalPago', node)
        if value is not None and 'FechaFinalPago' not in already_processed:
            already_processed.add('FechaFinalPago')
            self.FechaFinalPago = value
        value = find_attr_value_('NumDiasPagados', node)
        if value is not None and 'NumDiasPagados' not in already_processed:
            already_processed.add('NumDiasPagados')
            try:
                self.NumDiasPagados = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (NumDiasPagados): %s' % exp)
        value = find_attr_value_('TotalPercepciones', node)
        if value is not None and 'TotalPercepciones' not in already_processed:
            already_processed.add('TotalPercepciones')
            self.TotalPercepciones = value
        value = find_attr_value_('TotalDeducciones', node)
        if value is not None and 'TotalDeducciones' not in already_processed:
            already_processed.add('TotalDeducciones')
            self.TotalDeducciones = value
        value = find_attr_value_('TotalOtrosPagos', node)
        if value is not None and 'TotalOtrosPagos' not in already_processed:
            already_processed.add('TotalOtrosPagos')
            self.TotalOtrosPagos = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Emisor':
            obj_ = EmisorType.factory()
            obj_.build(child_)
            self.Emisor = obj_
            obj_.original_tagname_ = 'Emisor'
        elif nodeName_ == 'Receptor':
            obj_ = ReceptorType.factory()
            obj_.build(child_)
            self.Receptor = obj_
            obj_.original_tagname_ = 'Receptor'
        elif nodeName_ == 'Percepciones':
            obj_ = PercepcionesType.factory()
            obj_.build(child_)
            self.Percepciones = obj_
            obj_.original_tagname_ = 'Percepciones'
        elif nodeName_ == 'Deducciones':
            obj_ = DeduccionesType.factory()
            obj_.build(child_)
            self.Deducciones = obj_
            obj_.original_tagname_ = 'Deducciones'
        elif nodeName_ == 'OtrosPagos':
            obj_ = OtrosPagosType.factory()
            obj_.build(child_)
            self.OtrosPagos = obj_
            obj_.original_tagname_ = 'OtrosPagos'
        elif nodeName_ == 'Incapacidades':
            obj_ = IncapacidadesType.factory()
            obj_.build(child_)
            self.Incapacidades = obj_
            obj_.original_tagname_ = 'Incapacidades'
# end class Nomina


class EmisorType(GeneratedsSuper):
    """Atributo condicional para expresar la CURP del emisor del
    comprobante de nómina cuando es una persona física.Atributo
    condicional para expresar el registro patronal, clave de ramo -
    pagaduría o la que le asigne la institución de seguridad social
    al patrón, a 20 posiciones máximo. Se debe ingresar cuando se
    cuente con él, o se esté obligado conforme a otras disposiciones
    distintas a las fiscales.Atributo opcional para expresar el RFC
    de la persona que fungió como patrón cuando el pago al
    trabajador se realice a través de un tercero como vehículo o
    herramienta de pago."""
    subclass = None
    superclass = None
    def __init__(self, Curp=None, RegistroPatronal=None, RfcPatronOrigen=None, EntidadSNCF=None):
        self.original_tagname_ = None
        self.Curp = _cast(None, Curp)
        try:
            self.RegistroPatronal = _cast(None, RegistroPatronal.strip())
        except:
            self.RegistroPatronal = _cast(None, RegistroPatronal)
        self.RfcPatronOrigen = _cast(None, RfcPatronOrigen)
        self.EntidadSNCF = EntidadSNCF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EmisorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EmisorType.subclass:
            return EmisorType.subclass(*args_, **kwargs_)
        else:
            return EmisorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EntidadSNCF(self): return self.EntidadSNCF
    def set_EntidadSNCF(self, EntidadSNCF): self.EntidadSNCF = EntidadSNCF
    def get_Curp(self): return self.Curp
    def set_Curp(self, Curp): self.Curp = Curp
    def get_RegistroPatronal(self): return self.RegistroPatronal
    def set_RegistroPatronal(self, RegistroPatronal): self.RegistroPatronal = RegistroPatronal
    def get_RfcPatronOrigen(self): return self.RfcPatronOrigen
    def set_RfcPatronOrigen(self, RfcPatronOrigen): self.RfcPatronOrigen = RfcPatronOrigen
    def hasContent_(self):
        if (
            self.EntidadSNCF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='EmisorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EmisorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='EmisorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='EmisorType'):
        if self.Curp is not None and 'Curp' not in already_processed:
            already_processed.add('Curp')
            outfile.write(' Curp=%s' % (quote_attrib(self.Curp), ))
        if self.RegistroPatronal is not None and 'RegistroPatronal' not in already_processed:
            already_processed.add('RegistroPatronal')
            outfile.write(' RegistroPatronal=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.RegistroPatronal), input_name='RegistroPatronal')), ))
        if self.RfcPatronOrigen is not None and 'RfcPatronOrigen' not in already_processed:
            already_processed.add('RfcPatronOrigen')
            outfile.write(' RfcPatronOrigen=%s' % (quote_attrib(self.RfcPatronOrigen), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='EmisorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EntidadSNCF is not None:
            self.EntidadSNCF.export(outfile, level, namespace_, name_='EntidadSNCF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Curp', node)
        if value is not None and 'Curp' not in already_processed:
            already_processed.add('Curp')
            self.Curp = value
        value = find_attr_value_('RegistroPatronal', node)
        if value is not None and 'RegistroPatronal' not in already_processed:
            already_processed.add('RegistroPatronal')
            self.RegistroPatronal = value
        value = find_attr_value_('RfcPatronOrigen', node)
        if value is not None and 'RfcPatronOrigen' not in already_processed:
            already_processed.add('RfcPatronOrigen')
            self.RfcPatronOrigen = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EntidadSNCF':
            obj_ = EntidadSNCFType.factory()
            obj_.build(child_)
            self.EntidadSNCF = obj_
            obj_.original_tagname_ = 'EntidadSNCF'
# end class EmisorType


class EntidadSNCFType(GeneratedsSuper):
    """Atributo requerido para identificar el origen del recurso utilizado
    para el pago de nómina del personal que presta o desempeña un
    servicio personal subordinado o asimilado a salarios en las
    dependencias.Atributo condicional para expresar el monto del
    recurso pagado con cargo a sus participaciones u otros ingresos
    locales (importe bruto de los ingresos propios, es decir total
    de gravados y exentos), cuando el origen es mixto."""
    subclass = None
    superclass = None
    def __init__(self, OrigenRecurso=None, MontoRecursoPropio=None):
        self.original_tagname_ = None
        self.OrigenRecurso = _cast(None, OrigenRecurso)
        self.MontoRecursoPropio = _cast(None, MontoRecursoPropio)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EntidadSNCFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EntidadSNCFType.subclass:
            return EntidadSNCFType.subclass(*args_, **kwargs_)
        else:
            return EntidadSNCFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OrigenRecurso(self): return self.OrigenRecurso
    def set_OrigenRecurso(self, OrigenRecurso): self.OrigenRecurso = OrigenRecurso
    def get_MontoRecursoPropio(self): return self.MontoRecursoPropio
    def set_MontoRecursoPropio(self, MontoRecursoPropio): self.MontoRecursoPropio = MontoRecursoPropio
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='EntidadSNCFType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntidadSNCFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='EntidadSNCFType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='EntidadSNCFType'):
        if self.OrigenRecurso is not None and 'OrigenRecurso' not in already_processed:
            already_processed.add('OrigenRecurso')
            outfile.write(' OrigenRecurso=%s' % (quote_attrib(self.OrigenRecurso), ))
        if self.MontoRecursoPropio is not None and 'MontoRecursoPropio' not in already_processed:
            already_processed.add('MontoRecursoPropio')
            outfile.write(' MontoRecursoPropio=%s' % (quote_attrib(self.MontoRecursoPropio), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='EntidadSNCFType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('OrigenRecurso', node)
        if value is not None and 'OrigenRecurso' not in already_processed:
            already_processed.add('OrigenRecurso')
            self.OrigenRecurso = value
        value = find_attr_value_('MontoRecursoPropio', node)
        if value is not None and 'MontoRecursoPropio' not in already_processed:
            already_processed.add('MontoRecursoPropio')
            self.MontoRecursoPropio = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntidadSNCFType


class ReceptorType(GeneratedsSuper):
    """Atributo requerido para expresar la CURP del receptor del
    comprobante de nómina.Atributo condicional para expresar el
    número de seguridad social del trabajador. Se debe ingresar
    cuando se cuente con él, o se esté obligado conforme a otras
    disposiciones distintas a las fiscales.Atributo condicional para
    expresar la fecha de inicio de la relación laboral entre el
    empleador y el empleado. Se expresa en la forma aaaa-mm-dd, de
    acuerdo con la especificación ISO 8601. Se debe ingresar cuando
    se cuente con él, o se esté obligado conforme a otras
    disposiciones distintas a las fiscales.Atributo condicional para
    expresar el número de semanas o el periodo de años, meses y días
    que el empleado ha mantenido relación laboral con el empleador.
    Se debe ingresar cuando se cuente con él, o se esté obligado
    conforme a otras disposiciones distintas a las fiscales.Atributo
    requerido para expresar el tipo de contrato que tiene el
    trabajador.Atributo opcional para indicar si el trabajador está
    asociado a un sindicato. Si se omite se asume que no está
    asociado a algún sindicato.Atributo condicional para expresar el
    tipo de jornada que cubre el trabajador. Se debe ingresar cuando
    se esté obligado conforme a otras disposiciones distintas a las
    fiscales.Atributo requerido para la expresión de la clave del
    régimen por el cual se tiene contratado al trabajador.Atributo
    requerido para expresar el número de empleado de 1 a 15
    posiciones.Atributo opcional para la expresión del departamento
    o área a la que pertenece el trabajador.Atributo opcional para
    la expresión del puesto asignado al empleado o actividad que
    realiza.Atributo opcional para expresar la clave conforme a la
    Clase en que deben inscribirse los patrones, de acuerdo con las
    actividades que desempeñan sus trabajadores, según lo previsto
    en el artículo 196 del Reglamento en Materia de Afiliación
    Clasificación de Empresas, Recaudación y Fiscalización, o
    conforme con la normatividad del Instituto de Seguridad Social
    del trabajador. Se debe ingresar cuando se cuente con él, o se
    esté obligado conforme a otras disposiciones distintas a las
    fiscales.Atributo requerido para la forma en que se establece el
    pago del salario.Atributo condicional para la expresión de la
    clave del Banco conforme al catálogo, donde se realiza el
    depósito de nómina.Atributo condicional para la expresión de la
    cuenta bancaria a 11 posiciones o número de teléfono celular a
    10 posiciones o número de tarjeta de crédito, débito o servicios
    a 15 ó 16 posiciones o la CLABE a 18 posiciones o número de
    monedero electrónico, donde se realiza el depósito de
    nómina.Atributo opcional para expresar la retribución otorgada
    al trabajador, que se integra por los pagos hechos en efectivo
    por cuota diaria, gratificaciones, percepciones, alimentación,
    habitación, primas, comisiones, prestaciones en especie y
    cualquiera otra cantidad o prestación que se entregue al
    trabajador por su trabajo, sin considerar los conceptos que se
    excluyen de conformidad con el Artículo 27 de la Ley del Seguro
    Social, o la integración de los pagos conforme la normatividad
    del Instituto de Seguridad Social del trabajador. (Se emplea
    para pagar las cuotas y aportaciones de Seguridad Social). Se
    debe ingresar cuando se esté obligado conforme a otras
    disposiciones distintas a las fiscales.Atributo opcional para
    expresar el salario que se integra con los pagos hechos en
    efectivo por cuota diaria, gratificaciones, percepciones,
    habitación, primas, comisiones, prestaciones en especie y
    cualquier otra cantidad o prestación que se entregue al
    trabajador por su trabajo, de conformidad con el Art. 84 de la
    Ley Federal del Trabajo. (Se utiliza para el cálculo de las
    indemnizaciones). Se debe ingresar cuando se esté obligado
    conforme a otras disposiciones distintas a las fiscales.Atributo
    requerido para expresar la clave de la entidad federativa en
    donde el receptor del recibo prestó el servicio."""
    subclass = None
    superclass = None
    def __init__(self, Curp=None, NumSeguridadSocial=None, FechaInicioRelLaboral=None, Antiguedad=None, TipoContrato=None, Sindicalizado=None, TipoJornada=None, TipoRegimen=None, NumEmpleado=None, Departamento=None, Puesto=None, RiesgoPuesto=None, PeriodicidadPago=None, Banco=None, CuentaBancaria=None, SalarioBaseCotApor=None, SalarioDiarioIntegrado=None, ClaveEntFed=None, SubContratacion=None):
        self.original_tagname_ = None
        self.Curp = _cast(None, Curp)
        try:
            self.NumSeguridadSocial = _cast(None, NumSeguridadSocial.strip())
        except:
            self.NumSeguridadSocial = _cast(None, NumSeguridadSocial)
        self.FechaInicioRelLaboral = _cast(None, FechaInicioRelLaboral)
        try:
            self.Antiguedad = _cast(None, Antiguedad.strip())
        except:
          self.Antiguedad = _cast(None, Antiguedad)
        self.TipoContrato = _cast(None, TipoContrato)
        self.Sindicalizado = _cast(None, Sindicalizado)
        self.TipoJornada = _cast(None, TipoJornada)
        self.TipoRegimen = _cast(None, TipoRegimen)
        try:
            self.NumEmpleado = _cast(None, NumEmpleado.strip())
        except:
            self.NumEmpleado = _cast(None, NumEmpleado)
        self.Departamento = _cast(None, Departamento)
        self.Puesto = _cast(None, Puesto)
        self.RiesgoPuesto = _cast(None, RiesgoPuesto)
        self.PeriodicidadPago = _cast(None, PeriodicidadPago)
        self.Banco = _cast(None, Banco)
        self.CuentaBancaria = _cast(None, CuentaBancaria)
        self.SalarioBaseCotApor = _cast(None, SalarioBaseCotApor)
        self.SalarioDiarioIntegrado = _cast(None, SalarioDiarioIntegrado)
        self.ClaveEntFed = _cast(None, ClaveEntFed)
        if SubContratacion is None:
            self.SubContratacion = []
        else:
            self.SubContratacion = SubContratacion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReceptorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReceptorType.subclass:
            return ReceptorType.subclass(*args_, **kwargs_)
        else:
            return ReceptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubContratacion(self): return self.SubContratacion
    def set_SubContratacion(self, SubContratacion): self.SubContratacion = SubContratacion
    def add_SubContratacion(self, value): self.SubContratacion.append(value)
    def insert_SubContratacion_at(self, index, value): self.SubContratacion.insert(index, value)
    def replace_SubContratacion_at(self, index, value): self.SubContratacion[index] = value
    def get_Curp(self): return self.Curp
    def set_Curp(self, Curp): self.Curp = Curp
    def get_NumSeguridadSocial(self): return self.NumSeguridadSocial
    def set_NumSeguridadSocial(self, NumSeguridadSocial): self.NumSeguridadSocial = NumSeguridadSocial
    def get_FechaInicioRelLaboral(self): return self.FechaInicioRelLaboral
    def set_FechaInicioRelLaboral(self, FechaInicioRelLaboral): self.FechaInicioRelLaboral = FechaInicioRelLaboral
    def get_Antiguedad(self): return self.Antiguedad
    def set_Antiguedad(self, Antiguedad): self.Antiguedad = Antiguedad
    def get_TipoContrato(self): return self.TipoContrato
    def set_TipoContrato(self, TipoContrato): self.TipoContrato = TipoContrato
    def get_Sindicalizado(self): return self.Sindicalizado
    def set_Sindicalizado(self, Sindicalizado): self.Sindicalizado = Sindicalizado
    def get_TipoJornada(self): return self.TipoJornada
    def set_TipoJornada(self, TipoJornada): self.TipoJornada = TipoJornada
    def get_TipoRegimen(self): return self.TipoRegimen
    def set_TipoRegimen(self, TipoRegimen): self.TipoRegimen = TipoRegimen
    def get_NumEmpleado(self): return self.NumEmpleado
    def set_NumEmpleado(self, NumEmpleado): self.NumEmpleado = NumEmpleado
    def get_Departamento(self): return self.Departamento
    def set_Departamento(self, Departamento): self.Departamento = Departamento
    def get_Puesto(self): return self.Puesto
    def set_Puesto(self, Puesto): self.Puesto = Puesto
    def get_RiesgoPuesto(self): return self.RiesgoPuesto
    def set_RiesgoPuesto(self, RiesgoPuesto): self.RiesgoPuesto = RiesgoPuesto
    def get_PeriodicidadPago(self): return self.PeriodicidadPago
    def set_PeriodicidadPago(self, PeriodicidadPago): self.PeriodicidadPago = PeriodicidadPago
    def get_Banco(self): return self.Banco
    def set_Banco(self, Banco): self.Banco = Banco
    def get_CuentaBancaria(self): return self.CuentaBancaria
    def set_CuentaBancaria(self, CuentaBancaria): self.CuentaBancaria = CuentaBancaria
    def get_SalarioBaseCotApor(self): return self.SalarioBaseCotApor
    def set_SalarioBaseCotApor(self, SalarioBaseCotApor): self.SalarioBaseCotApor = SalarioBaseCotApor
    def get_SalarioDiarioIntegrado(self): return self.SalarioDiarioIntegrado
    def set_SalarioDiarioIntegrado(self, SalarioDiarioIntegrado): self.SalarioDiarioIntegrado = SalarioDiarioIntegrado
    def get_ClaveEntFed(self): return self.ClaveEntFed
    def set_ClaveEntFed(self, ClaveEntFed): self.ClaveEntFed = ClaveEntFed
    def hasContent_(self):
        if (
            self.SubContratacion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='ReceptorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReceptorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='ReceptorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='ReceptorType'):
        if self.Curp is not None and 'Curp' not in already_processed:
            already_processed.add('Curp')
            outfile.write(' Curp=%s' % (quote_attrib(self.Curp), ))
        if self.NumSeguridadSocial is not None and 'NumSeguridadSocial' not in already_processed:
            already_processed.add('NumSeguridadSocial')
            outfile.write(' NumSeguridadSocial=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumSeguridadSocial), input_name='NumSeguridadSocial')), ))
        if self.FechaInicioRelLaboral is not None and 'FechaInicioRelLaboral' not in already_processed:
            already_processed.add('FechaInicioRelLaboral')
            outfile.write(' FechaInicioRelLaboral=%s' % (quote_attrib(self.FechaInicioRelLaboral), ))
        if self.Antiguedad is not None and u'Antigüedad' not in already_processed:
            already_processed.add(u'Antigüedad')
            outfile.write(u' Antigüedad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Antiguedad), input_name=u'Antigüedad')), ))
        if self.TipoContrato is not None and 'TipoContrato' not in already_processed:
            already_processed.add('TipoContrato')
            outfile.write(' TipoContrato=%s' % (quote_attrib(self.TipoContrato), ))
        if self.Sindicalizado is not None and 'Sindicalizado' not in already_processed:
            already_processed.add('Sindicalizado')
            outfile.write(' Sindicalizado=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Sindicalizado), input_name='Sindicalizado')), ))
        if self.TipoJornada is not None and 'TipoJornada' not in already_processed:
            already_processed.add('TipoJornada')
            outfile.write(' TipoJornada=%s' % (quote_attrib(self.TipoJornada), ))
        if self.TipoRegimen is not None and 'TipoRegimen' not in already_processed:
            already_processed.add('TipoRegimen')
            outfile.write(' TipoRegimen=%s' % (quote_attrib(self.TipoRegimen), ))
        if self.NumEmpleado is not None and 'NumEmpleado' not in already_processed:
            already_processed.add('NumEmpleado')
            outfile.write(' NumEmpleado=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.NumEmpleado), input_name='NumEmpleado')), ))
        if self.Departamento is not None and 'Departamento' not in already_processed:
            already_processed.add('Departamento')
            outfile.write(' Departamento=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Departamento), input_name='Departamento')), ))
        if self.Puesto is not None and 'Puesto' not in already_processed:
            already_processed.add('Puesto')
            outfile.write(' Puesto=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Puesto), input_name='Puesto')), ))
        if self.RiesgoPuesto is not None and 'RiesgoPuesto' not in already_processed:
            already_processed.add('RiesgoPuesto')
            outfile.write(' RiesgoPuesto=%s' % (quote_attrib(self.RiesgoPuesto), ))
        if self.PeriodicidadPago is not None and 'PeriodicidadPago' not in already_processed:
            already_processed.add('PeriodicidadPago')
            outfile.write(' PeriodicidadPago=%s' % (quote_attrib(self.PeriodicidadPago), ))
        if self.Banco is not None and 'Banco' not in already_processed:
            already_processed.add('Banco')
            outfile.write(' Banco=%s' % (quote_attrib(self.Banco), ))
        if self.CuentaBancaria is not None and 'CuentaBancaria' not in already_processed:
            already_processed.add('CuentaBancaria')
            outfile.write(' CuentaBancaria=%s' % (quote_attrib(self.CuentaBancaria), ))
        if self.SalarioBaseCotApor is not None and 'SalarioBaseCotApor' not in already_processed:
            already_processed.add('SalarioBaseCotApor')
            outfile.write(' SalarioBaseCotApor=%s' % (quote_attrib(self.SalarioBaseCotApor), ))
        if self.SalarioDiarioIntegrado is not None and 'SalarioDiarioIntegrado' not in already_processed:
            already_processed.add('SalarioDiarioIntegrado')
            outfile.write(' SalarioDiarioIntegrado=%s' % (quote_attrib(self.SalarioDiarioIntegrado), ))
        if self.ClaveEntFed is not None and 'ClaveEntFed' not in already_processed:
            already_processed.add('ClaveEntFed')
            outfile.write(' ClaveEntFed=%s' % (quote_attrib(self.ClaveEntFed), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='ReceptorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SubContratacion_ in self.SubContratacion:
            SubContratacion_.export(outfile, level, namespace_, name_='SubContratacion', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Curp', node)
        if value is not None and 'Curp' not in already_processed:
            already_processed.add('Curp')
            self.Curp = value
        value = find_attr_value_('NumSeguridadSocial', node)
        if value is not None and 'NumSeguridadSocial' not in already_processed:
            already_processed.add('NumSeguridadSocial')
            self.NumSeguridadSocial = value
        value = find_attr_value_('FechaInicioRelLaboral', node)
        if value is not None and 'FechaInicioRelLaboral' not in already_processed:
            already_processed.add('FechaInicioRelLaboral')
            self.FechaInicioRelLaboral = value
        value = find_attr_value_(u'Antigüedad', node)
        if value is not None and u'Antigüedad' not in already_processed:
            already_processed.add(u'Antigüedad')
            self.Antiguedad = value
        value = find_attr_value_('TipoContrato', node)
        if value is not None and 'TipoContrato' not in already_processed:
            already_processed.add('TipoContrato')
            self.TipoContrato = value
        value = find_attr_value_('Sindicalizado', node)
        if value is not None and 'Sindicalizado' not in already_processed:
            already_processed.add('Sindicalizado')
            self.Sindicalizado = value
        value = find_attr_value_('TipoJornada', node)
        if value is not None and 'TipoJornada' not in already_processed:
            already_processed.add('TipoJornada')
            self.TipoJornada = value
        value = find_attr_value_('TipoRegimen', node)
        if value is not None and 'TipoRegimen' not in already_processed:
            already_processed.add('TipoRegimen')
            self.TipoRegimen = value
        value = find_attr_value_('NumEmpleado', node)
        if value is not None and 'NumEmpleado' not in already_processed:
            already_processed.add('NumEmpleado')
            self.NumEmpleado = value
        value = find_attr_value_('Departamento', node)
        if value is not None and 'Departamento' not in already_processed:
            already_processed.add('Departamento')
            self.Departamento = value
        value = find_attr_value_('Puesto', node)
        if value is not None and 'Puesto' not in already_processed:
            already_processed.add('Puesto')
            self.Puesto = value
        value = find_attr_value_('RiesgoPuesto', node)
        if value is not None and 'RiesgoPuesto' not in already_processed:
            already_processed.add('RiesgoPuesto')
            self.RiesgoPuesto = value
        value = find_attr_value_('PeriodicidadPago', node)
        if value is not None and 'PeriodicidadPago' not in already_processed:
            already_processed.add('PeriodicidadPago')
            self.PeriodicidadPago = value
        value = find_attr_value_('Banco', node)
        if value is not None and 'Banco' not in already_processed:
            already_processed.add('Banco')
            self.Banco = value
        value = find_attr_value_('CuentaBancaria', node)
        if value is not None and 'CuentaBancaria' not in already_processed:
            already_processed.add('CuentaBancaria')
            self.CuentaBancaria = value
        value = find_attr_value_('SalarioBaseCotApor', node)
        if value is not None and 'SalarioBaseCotApor' not in already_processed:
            already_processed.add('SalarioBaseCotApor')
            self.SalarioBaseCotApor = value
        value = find_attr_value_('SalarioDiarioIntegrado', node)
        if value is not None and 'SalarioDiarioIntegrado' not in already_processed:
            already_processed.add('SalarioDiarioIntegrado')
            self.SalarioDiarioIntegrado = value
        value = find_attr_value_('ClaveEntFed', node)
        if value is not None and 'ClaveEntFed' not in already_processed:
            already_processed.add('ClaveEntFed')
            self.ClaveEntFed = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubContratacion':
            obj_ = SubContratacionType.factory()
            obj_.build(child_)
            self.SubContratacion.append(obj_)
            obj_.original_tagname_ = 'SubContratacion'
# end class ReceptorType


class SubContratacionType(GeneratedsSuper):
    """Atributo requerido para expresar el RFC de la persona que
    subcontrata.Atributo requerido para expresar el porcentaje del
    tiempo que prestó sus servicios con el RFC que lo subcontrata."""
    subclass = None
    superclass = None
    def __init__(self, RfcLabora=None, PorcentajeTiempo=None):
        self.original_tagname_ = None
        self.RfcLabora = _cast(None, RfcLabora)
        try:
            self.PorcentajeTiempo = _cast(float, PorcentajeTiempo.strip())
        except:
            self.PorcentajeTiempo = _cast(float, PorcentajeTiempo)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubContratacionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubContratacionType.subclass:
            return SubContratacionType.subclass(*args_, **kwargs_)
        else:
            return SubContratacionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RfcLabora(self): return self.RfcLabora
    def set_RfcLabora(self, RfcLabora): self.RfcLabora = RfcLabora
    def get_PorcentajeTiempo(self): return self.PorcentajeTiempo
    def set_PorcentajeTiempo(self, PorcentajeTiempo): self.PorcentajeTiempo = PorcentajeTiempo
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='SubContratacionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubContratacionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='SubContratacionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='SubContratacionType'):
        if self.RfcLabora is not None and 'RfcLabora' not in already_processed:
            already_processed.add('RfcLabora')
            outfile.write(' RfcLabora=%s' % (quote_attrib(self.RfcLabora), ))
        if self.PorcentajeTiempo is not None and 'PorcentajeTiempo' not in already_processed:
            already_processed.add('PorcentajeTiempo')
            outfile.write(' PorcentajeTiempo="%s"' % self.gds_format_porcentaje_float(self.PorcentajeTiempo, input_name='PorcentajeTiempo'))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='SubContratacionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('RfcLabora', node)
        if value is not None and 'RfcLabora' not in already_processed:
            already_processed.add('RfcLabora')
            self.RfcLabora = value
        value = find_attr_value_('PorcentajeTiempo', node)
        if value is not None and 'PorcentajeTiempo' not in already_processed:
            already_processed.add('PorcentajeTiempo')
            try:
                self.PorcentajeTiempo = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PorcentajeTiempo): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SubContratacionType


class PercepcionesType(GeneratedsSuper):
    """Atributo condicional para expresar el total de percepciones brutas
    (gravadas y exentas) por sueldos y salarios y conceptos
    asimilados a salarios.Atributo condicional para expresar el
    importe exento y gravado de las claves tipo percepción 022 Prima
    por Antigüedad, 023 Pagos por separación y 025
    Indemnizaciones.Atributo condicional para expresar el importe
    exento y gravado de las claves tipo percepción 039 Jubilaciones,
    pensiones o haberes de retiro en una exhibición y 044
    Jubilaciones, pensiones o haberes de retiro en
    parcialidades.Atributo requerido para expresar el total de
    percepciones gravadas que se relacionan en el
    comprobante.Atributo requerido para expresar el total de
    percepciones exentas que se relacionan en el comprobante."""
    subclass = None
    superclass = None
    def __init__(self, TotalSueldos=None, TotalSeparacionIndemnizacion=None, TotalJubilacionPensionRetiro=None, TotalGravado=None, TotalExento=None, Percepcion=None, JubilacionPensionRetiro=None, SeparacionIndemnizacion=None):
        self.original_tagname_ = None
        self.TotalSueldos = _cast(None, TotalSueldos)
        self.TotalSeparacionIndemnizacion = _cast(None, TotalSeparacionIndemnizacion)
        self.TotalJubilacionPensionRetiro = _cast(None, TotalJubilacionPensionRetiro)
        self.TotalGravado = _cast(None, TotalGravado)
        self.TotalExento = _cast(None, TotalExento)
        if Percepcion is None:
            self.Percepcion = []
        else:
            self.Percepcion = Percepcion
        self.JubilacionPensionRetiro = JubilacionPensionRetiro
        self.SeparacionIndemnizacion = SeparacionIndemnizacion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PercepcionesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PercepcionesType.subclass:
            return PercepcionesType.subclass(*args_, **kwargs_)
        else:
            return PercepcionesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Percepcion(self): return self.Percepcion
    def set_Percepcion(self, Percepcion): self.Percepcion = Percepcion
    def add_Percepcion(self, value): self.Percepcion.append(value)
    def insert_Percepcion_at(self, index, value): self.Percepcion.insert(index, value)
    def replace_Percepcion_at(self, index, value): self.Percepcion[index] = value
    def get_JubilacionPensionRetiro(self): return self.JubilacionPensionRetiro
    def set_JubilacionPensionRetiro(self, JubilacionPensionRetiro): self.JubilacionPensionRetiro = JubilacionPensionRetiro
    def get_SeparacionIndemnizacion(self): return self.SeparacionIndemnizacion
    def set_SeparacionIndemnizacion(self, SeparacionIndemnizacion): self.SeparacionIndemnizacion = SeparacionIndemnizacion
    def get_TotalSueldos(self): return self.TotalSueldos
    def set_TotalSueldos(self, TotalSueldos): self.TotalSueldos = TotalSueldos
    def get_TotalSeparacionIndemnizacion(self): return self.TotalSeparacionIndemnizacion
    def set_TotalSeparacionIndemnizacion(self, TotalSeparacionIndemnizacion): self.TotalSeparacionIndemnizacion = TotalSeparacionIndemnizacion
    def get_TotalJubilacionPensionRetiro(self): return self.TotalJubilacionPensionRetiro
    def set_TotalJubilacionPensionRetiro(self, TotalJubilacionPensionRetiro): self.TotalJubilacionPensionRetiro = TotalJubilacionPensionRetiro
    def get_TotalGravado(self): return self.TotalGravado
    def set_TotalGravado(self, TotalGravado): self.TotalGravado = TotalGravado
    def get_TotalExento(self): return self.TotalExento
    def set_TotalExento(self, TotalExento): self.TotalExento = TotalExento
    def hasContent_(self):
        if (
            self.Percepcion or
            self.JubilacionPensionRetiro is not None or
            self.SeparacionIndemnizacion is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='PercepcionesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PercepcionesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='PercepcionesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='PercepcionesType'):
        if self.TotalSueldos is not None and 'TotalSueldos' not in already_processed:
            already_processed.add('TotalSueldos')
            outfile.write(' TotalSueldos=%s' % (quote_attrib("%.2f" % float(self.TotalSueldos)), ))
        if self.TotalSeparacionIndemnizacion is not None and 'TotalSeparacionIndemnizacion' not in already_processed:
            already_processed.add('TotalSeparacionIndemnizacion')
            outfile.write(' TotalSeparacionIndemnizacion=%s' % (quote_attrib(self.TotalSeparacionIndemnizacion), ))
        if self.TotalJubilacionPensionRetiro is not None and 'TotalJubilacionPensionRetiro' not in already_processed:
            already_processed.add('TotalJubilacionPensionRetiro')
            outfile.write(' TotalJubilacionPensionRetiro=%s' % (quote_attrib(self.TotalJubilacionPensionRetiro), ))
        if self.TotalGravado is not None and 'TotalGravado' not in already_processed:
            already_processed.add('TotalGravado')
            #outfile.write(' TotalGravado=%s' % (quote_attrib(self.TotalGravado), ))
            outfile.write(' TotalGravado=%s' % (quote_attrib("%.2f" % float(self.TotalGravado)), ))
        if self.TotalExento is not None and 'TotalExento' not in already_processed:
            already_processed.add('TotalExento')
            outfile.write(' TotalExento=%s' % (quote_attrib("%.2f" % float(self.TotalExento)), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='PercepcionesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Percepcion_ in self.Percepcion:
            Percepcion_.export(outfile, level, namespace_, name_='Percepcion', pretty_print=pretty_print)
        if self.JubilacionPensionRetiro is not None:
            self.JubilacionPensionRetiro.export(outfile, level, namespace_, name_='JubilacionPensionRetiro', pretty_print=pretty_print)
        if self.SeparacionIndemnizacion is not None:
            self.SeparacionIndemnizacion.export(outfile, level, namespace_, name_='SeparacionIndemnizacion', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TotalSueldos', node)
        if value is not None and 'TotalSueldos' not in already_processed:
            already_processed.add('TotalSueldos')
            self.TotalSueldos = value
        value = find_attr_value_('TotalSeparacionIndemnizacion', node)
        if value is not None and 'TotalSeparacionIndemnizacion' not in already_processed:
            already_processed.add('TotalSeparacionIndemnizacion')
            self.TotalSeparacionIndemnizacion = value
        value = find_attr_value_('TotalJubilacionPensionRetiro', node)
        if value is not None and 'TotalJubilacionPensionRetiro' not in already_processed:
            already_processed.add('TotalJubilacionPensionRetiro')
            self.TotalJubilacionPensionRetiro = value
        value = find_attr_value_('TotalGravado', node)
        if value is not None and 'TotalGravado' not in already_processed:
            already_processed.add('TotalGravado')
            self.TotalGravado = value
        value = find_attr_value_('TotalExento', node)
        if value is not None and 'TotalExento' not in already_processed:
            already_processed.add('TotalExento')
            self.TotalExento = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Percepcion':
            obj_ = PercepcionType.factory()
            obj_.build(child_)
            self.Percepcion.append(obj_)
            obj_.original_tagname_ = 'Percepcion'
        elif nodeName_ == 'JubilacionPensionRetiro':
            obj_ = JubilacionPensionRetiroType.factory()
            obj_.build(child_)
            self.JubilacionPensionRetiro = obj_
            obj_.original_tagname_ = 'JubilacionPensionRetiro'
        elif nodeName_ == 'SeparacionIndemnizacion':
            obj_ = SeparacionIndemnizacionType.factory()
            obj_.build(child_)
            self.SeparacionIndemnizacion = obj_
            obj_.original_tagname_ = 'SeparacionIndemnizacion'
# end class PercepcionesType


class PercepcionType(GeneratedsSuper):
    """Atributo requerido para expresar la Clave agrupadora bajo la cual se
    clasifica la percepción.Atributo requerido para expresar la
    clave de percepción de nómina propia de la contabilidad de cada
    patrón, puede conformarse desde 3 hasta 15 caracteres.Atributo
    requerido para la descripción del concepto de percepciónAtributo
    requerido, representa el importe gravado de un concepto de
    percepción.Atributo requerido, representa el importe exento de
    un concepto de percepción."""
    subclass = None
    superclass = None
    def __init__(self, TipoPercepcion=None, Clave=None, Concepto=None, ImporteGravado=None, ImporteExento=None, AccionesOTitulos=None, HorasExtra=None):
        self.original_tagname_ = None
        self.TipoPercepcion = _cast(None, TipoPercepcion)
        try:
            self.Clave = _cast(None, Clave.strip())
        except:
            self.Clave = _cast(None, Clave)
        self.Concepto = _cast(None, Concepto)
        self.ImporteGravado = _cast(None, ImporteGravado)
        self.ImporteExento = _cast(None, ImporteExento)
        self.AccionesOTitulos = AccionesOTitulos
        if HorasExtra is None:
            self.HorasExtra = []
        else:
            self.HorasExtra = HorasExtra
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PercepcionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PercepcionType.subclass:
            return PercepcionType.subclass(*args_, **kwargs_)
        else:
            return PercepcionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AccionesOTitulos(self): return self.AccionesOTitulos
    def set_AccionesOTitulos(self, AccionesOTitulos): self.AccionesOTitulos = AccionesOTitulos
    def get_HorasExtra(self): return self.HorasExtra
    def set_HorasExtra(self, HorasExtra): self.HorasExtra = HorasExtra
    def add_HorasExtra(self, value): self.HorasExtra.append(value)
    def insert_HorasExtra_at(self, index, value): self.HorasExtra.insert(index, value)
    def replace_HorasExtra_at(self, index, value): self.HorasExtra[index] = value
    def get_TipoPercepcion(self): return self.TipoPercepcion
    def set_TipoPercepcion(self, TipoPercepcion): self.TipoPercepcion = TipoPercepcion
    def get_Clave(self): return self.Clave
    def set_Clave(self, Clave): self.Clave = Clave
    def get_Concepto(self): return self.Concepto
    def set_Concepto(self, Concepto): self.Concepto = Concepto
    def get_ImporteGravado(self): return self.ImporteGravado
    def set_ImporteGravado(self, ImporteGravado): self.ImporteGravado = ImporteGravado
    def get_ImporteExento(self): return self.ImporteExento
    def set_ImporteExento(self, ImporteExento): self.ImporteExento = ImporteExento
    def hasContent_(self):
        if (
            self.AccionesOTitulos is not None or
            self.HorasExtra
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='PercepcionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PercepcionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='PercepcionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='PercepcionType'):
        if self.TipoPercepcion is not None and 'TipoPercepcion' not in already_processed:
            already_processed.add('TipoPercepcion')
            outfile.write(' TipoPercepcion=%s' % (quote_attrib(self.TipoPercepcion), ))
        if self.Clave is not None and 'Clave' not in already_processed:
            already_processed.add('Clave')
            outfile.write(' Clave=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Clave), input_name='Clave')), ))
        if self.Concepto is not None and 'Concepto' not in already_processed:
            already_processed.add('Concepto')
            outfile.write(' Concepto=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Concepto), input_name='Concepto')), ))
        if self.ImporteGravado is not None and 'ImporteGravado' not in already_processed:
            already_processed.add('ImporteGravado')
            outfile.write(' ImporteGravado=%s' % (quote_attrib("%.2f" % float(self.ImporteGravado)), ))
        if self.ImporteExento is not None and 'ImporteExento' not in already_processed:
            already_processed.add('ImporteExento')
            outfile.write(' ImporteExento=%s' % (quote_attrib("%.2f" % float(self.ImporteExento)), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='PercepcionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AccionesOTitulos is not None:
            self.AccionesOTitulos.export(outfile, level, namespace_, name_='AccionesOTitulos', pretty_print=pretty_print)
        for HorasExtra_ in self.HorasExtra:
            HorasExtra_.export(outfile, level, namespace_, name_='HorasExtra', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TipoPercepcion', node)
        if value is not None and 'TipoPercepcion' not in already_processed:
            already_processed.add('TipoPercepcion')
            self.TipoPercepcion = value
        value = find_attr_value_('Clave', node)
        if value is not None and 'Clave' not in already_processed:
            already_processed.add('Clave')
            self.Clave = value
        value = find_attr_value_('Concepto', node)
        if value is not None and 'Concepto' not in already_processed:
            already_processed.add('Concepto')
            self.Concepto = value
        value = find_attr_value_('ImporteGravado', node)
        if value is not None and 'ImporteGravado' not in already_processed:
            already_processed.add('ImporteGravado')
            self.ImporteGravado = value
        value = find_attr_value_('ImporteExento', node)
        if value is not None and 'ImporteExento' not in already_processed:
            already_processed.add('ImporteExento')
            self.ImporteExento = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AccionesOTitulos':
            obj_ = AccionesOTitulosType.factory()
            obj_.build(child_)
            self.AccionesOTitulos = obj_
            obj_.original_tagname_ = 'AccionesOTitulos'
        elif nodeName_ == 'HorasExtra':
            obj_ = HorasExtraType.factory()
            obj_.build(child_)
            self.HorasExtra.append(obj_)
            obj_.original_tagname_ = 'HorasExtra'
# end class PercepcionType


class AccionesOTitulosType(GeneratedsSuper):
    """Atributo requerido para expresar el valor de mercado de las Acciones
    o Títulos valor al ejercer la opción.Atributo requerido para
    expresar el precio establecido al otorgarse la opción de
    ingresos en acciones o títulos valor."""
    subclass = None
    superclass = None
    def __init__(self, ValorMercado=None, PrecioAlOtorgarse=None):
        self.original_tagname_ = None
        self.ValorMercado = _cast(float, ValorMercado)
        self.PrecioAlOtorgarse = _cast(float, PrecioAlOtorgarse)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccionesOTitulosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccionesOTitulosType.subclass:
            return AccionesOTitulosType.subclass(*args_, **kwargs_)
        else:
            return AccionesOTitulosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ValorMercado(self): return self.ValorMercado
    def set_ValorMercado(self, ValorMercado): self.ValorMercado = ValorMercado
    def get_PrecioAlOtorgarse(self): return self.PrecioAlOtorgarse
    def set_PrecioAlOtorgarse(self, PrecioAlOtorgarse): self.PrecioAlOtorgarse = PrecioAlOtorgarse
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='AccionesOTitulosType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccionesOTitulosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='AccionesOTitulosType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='AccionesOTitulosType'):
        if self.ValorMercado is not None and 'ValorMercado' not in already_processed:
            already_processed.add('ValorMercado')
            outfile.write(' ValorMercado="%s"' % self.gds_format_float(self.ValorMercado, input_name='ValorMercado'))
        if self.PrecioAlOtorgarse is not None and 'PrecioAlOtorgarse' not in already_processed:
            already_processed.add('PrecioAlOtorgarse')
            outfile.write(' PrecioAlOtorgarse="%s"' % self.gds_format_float(self.PrecioAlOtorgarse, input_name='PrecioAlOtorgarse'))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='AccionesOTitulosType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ValorMercado', node)
        if value is not None and 'ValorMercado' not in already_processed:
            already_processed.add('ValorMercado')
            try:
                self.ValorMercado = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (ValorMercado): %s' % exp)
        value = find_attr_value_('PrecioAlOtorgarse', node)
        if value is not None and 'PrecioAlOtorgarse' not in already_processed:
            already_processed.add('PrecioAlOtorgarse')
            try:
                self.PrecioAlOtorgarse = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (PrecioAlOtorgarse): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccionesOTitulosType


class HorasExtraType(GeneratedsSuper):
    """Atributo requerido para expresar el número de días en que el
    trabajador realizó horas extra en el periodo.Atributo requerido
    para expresar el tipo de pago de las horas extra.Atributo
    requerido para expresar el número de horas extra trabajadas en
    el periodo.Atributo requerido para expresar el importe pagado
    por las horas extra."""
    subclass = None
    superclass = None
    def __init__(self, Dias=None, TipoHoras=None, HorasExtra=None, ImportePagado=None):
        self.original_tagname_ = None
        self.Dias = _cast(int, Dias)
        self.TipoHoras = _cast(None, TipoHoras)
        self.HorasExtra = _cast(int, HorasExtra)
        self.ImportePagado = _cast(None, ImportePagado)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HorasExtraType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HorasExtraType.subclass:
            return HorasExtraType.subclass(*args_, **kwargs_)
        else:
            return HorasExtraType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Dias(self): return self.Dias
    def set_Dias(self, Dias): self.Dias = Dias
    def get_TipoHoras(self): return self.TipoHoras
    def set_TipoHoras(self, TipoHoras): self.TipoHoras = TipoHoras
    def get_HorasExtra(self): return self.HorasExtra
    def set_HorasExtra(self, HorasExtra): self.HorasExtra = HorasExtra
    def get_ImportePagado(self): return self.ImportePagado
    def set_ImportePagado(self, ImportePagado): self.ImportePagado = ImportePagado
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='HorasExtraType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HorasExtraType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='HorasExtraType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='HorasExtraType'):
        if self.Dias is not None and 'Dias' not in already_processed:
            already_processed.add('Dias')
            outfile.write(' Dias="%s"' % self.gds_format_integer(self.Dias, input_name='Dias'))
        if self.TipoHoras is not None and 'TipoHoras' not in already_processed:
            already_processed.add('TipoHoras')
            outfile.write(' TipoHoras=%s' % (quote_attrib(self.TipoHoras), ))
        if self.HorasExtra is not None and 'HorasExtra' not in already_processed:
            already_processed.add('HorasExtra')
            outfile.write(' HorasExtra="%s"' % self.gds_format_integer(self.HorasExtra, input_name='HorasExtra'))
        if self.ImportePagado is not None and 'ImportePagado' not in already_processed:
            already_processed.add('ImportePagado')
            outfile.write(' ImportePagado=%s' % (quote_attrib(self.ImportePagado), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='HorasExtraType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Dias', node)
        if value is not None and 'Dias' not in already_processed:
            already_processed.add('Dias')
            try:
                self.Dias = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('TipoHoras', node)
        if value is not None and 'TipoHoras' not in already_processed:
            already_processed.add('TipoHoras')
            self.TipoHoras = value
        value = find_attr_value_('HorasExtra', node)
        if value is not None and 'HorasExtra' not in already_processed:
            already_processed.add('HorasExtra')
            try:
                self.HorasExtra = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ImportePagado', node)
        if value is not None and 'ImportePagado' not in already_processed:
            already_processed.add('ImportePagado')
            self.ImportePagado = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HorasExtraType


class JubilacionPensionRetiroType(GeneratedsSuper):
    """Atributo condicional que indica el monto total del pago cuando se
    realiza en una sola exhibición.Atributo condicional para
    expresar los ingresos totales por pago cuando se hace en
    parcialidades.Atributo condicional para expresar el monto diario
    percibido por jubilación, pensiones o haberes de retiro cuando
    se realiza en parcialidades.Atributo requerido para expresar los
    ingresos acumulables.Atributo requerido para expresar los
    ingresos no acumulables."""
    subclass = None
    superclass = None
    def __init__(self, TotalUnaExhibicion=None, TotalParcialidad=None, MontoDiario=None, IngresoAcumulable=None, IngresoNoAcumulable=None):
        self.original_tagname_ = None
        self.TotalUnaExhibicion = _cast(None, TotalUnaExhibicion)
        self.TotalParcialidad = _cast(None, TotalParcialidad)
        self.MontoDiario = _cast(None, MontoDiario)
        self.IngresoAcumulable = _cast(None, IngresoAcumulable)
        self.IngresoNoAcumulable = _cast(None, IngresoNoAcumulable)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, JubilacionPensionRetiroType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if JubilacionPensionRetiroType.subclass:
            return JubilacionPensionRetiroType.subclass(*args_, **kwargs_)
        else:
            return JubilacionPensionRetiroType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TotalUnaExhibicion(self): return self.TotalUnaExhibicion
    def set_TotalUnaExhibicion(self, TotalUnaExhibicion): self.TotalUnaExhibicion = TotalUnaExhibicion
    def get_TotalParcialidad(self): return self.TotalParcialidad
    def set_TotalParcialidad(self, TotalParcialidad): self.TotalParcialidad = TotalParcialidad
    def get_MontoDiario(self): return self.MontoDiario
    def set_MontoDiario(self, MontoDiario): self.MontoDiario = MontoDiario
    def get_IngresoAcumulable(self): return self.IngresoAcumulable
    def set_IngresoAcumulable(self, IngresoAcumulable): self.IngresoAcumulable = IngresoAcumulable
    def get_IngresoNoAcumulable(self): return self.IngresoNoAcumulable
    def set_IngresoNoAcumulable(self, IngresoNoAcumulable): self.IngresoNoAcumulable = IngresoNoAcumulable
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='JubilacionPensionRetiroType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='JubilacionPensionRetiroType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='JubilacionPensionRetiroType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='JubilacionPensionRetiroType'):
        if self.TotalUnaExhibicion is not None and 'TotalUnaExhibicion' not in already_processed:
            already_processed.add('TotalUnaExhibicion')
            outfile.write(' TotalUnaExhibicion=%s' % (quote_attrib(self.TotalUnaExhibicion), ))
        if self.TotalParcialidad is not None and 'TotalParcialidad' not in already_processed:
            already_processed.add('TotalParcialidad')
            outfile.write(' TotalParcialidad=%s' % (quote_attrib(self.TotalParcialidad), ))
        if self.MontoDiario is not None and 'MontoDiario' not in already_processed:
            already_processed.add('MontoDiario')
            outfile.write(' MontoDiario=%s' % (quote_attrib(self.MontoDiario), ))
        if self.IngresoAcumulable is not None and 'IngresoAcumulable' not in already_processed:
            already_processed.add('IngresoAcumulable')
            outfile.write(' IngresoAcumulable=%s' % (quote_attrib(self.IngresoAcumulable), ))
        if self.IngresoNoAcumulable is not None and 'IngresoNoAcumulable' not in already_processed:
            already_processed.add('IngresoNoAcumulable')
            outfile.write(' IngresoNoAcumulable=%s' % (quote_attrib(self.IngresoNoAcumulable), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='JubilacionPensionRetiroType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TotalUnaExhibicion', node)
        if value is not None and 'TotalUnaExhibicion' not in already_processed:
            already_processed.add('TotalUnaExhibicion')
            self.TotalUnaExhibicion = value
        value = find_attr_value_('TotalParcialidad', node)
        if value is not None and 'TotalParcialidad' not in already_processed:
            already_processed.add('TotalParcialidad')
            self.TotalParcialidad = value
        value = find_attr_value_('MontoDiario', node)
        if value is not None and 'MontoDiario' not in already_processed:
            already_processed.add('MontoDiario')
            self.MontoDiario = value
        value = find_attr_value_('IngresoAcumulable', node)
        if value is not None and 'IngresoAcumulable' not in already_processed:
            already_processed.add('IngresoAcumulable')
            self.IngresoAcumulable = value
        value = find_attr_value_('IngresoNoAcumulable', node)
        if value is not None and 'IngresoNoAcumulable' not in already_processed:
            already_processed.add('IngresoNoAcumulable')
            self.IngresoNoAcumulable = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class JubilacionPensionRetiroType


class SeparacionIndemnizacionType(GeneratedsSuper):
    """Atributo requerido que indica el monto total del pago.Atributo
    requerido para expresar el número de años de servicio del
    trabajador. Se redondea al entero superior si la cifra contiene
    años y meses y hay más de 6 meses.Atributo requerido que indica
    el último sueldo mensual ordinario.Atributo requerido para
    expresar los ingresos acumulables.Atributo requerido que indica
    los ingresos no acumulables."""
    subclass = None
    superclass = None
    def __init__(self, TotalPagado=None, NumAnosServicio=None, UltimoSueldoMensOrd=None, IngresoAcumulable=None, IngresoNoAcumulable=None):
        self.original_tagname_ = None
        self.TotalPagado = _cast(None, TotalPagado)
        self.NumAnosServicio = _cast(int, NumAnosServicio)
        self.UltimoSueldoMensOrd = _cast(None, UltimoSueldoMensOrd)
        self.IngresoAcumulable = _cast(None, IngresoAcumulable)
        self.IngresoNoAcumulable = _cast(None, IngresoNoAcumulable)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SeparacionIndemnizacionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SeparacionIndemnizacionType.subclass:
            return SeparacionIndemnizacionType.subclass(*args_, **kwargs_)
        else:
            return SeparacionIndemnizacionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TotalPagado(self): return self.TotalPagado
    def set_TotalPagado(self, TotalPagado): self.TotalPagado = TotalPagado
    def get_NumAnosServicio(self): return self.NumAnosServicio
    def set_NumAnosServicio(self, NumAnosServicio): self.NumAnosServicio = NumAnosServicio
    def get_UltimoSueldoMensOrd(self): return self.UltimoSueldoMensOrd
    def set_UltimoSueldoMensOrd(self, UltimoSueldoMensOrd): self.UltimoSueldoMensOrd = UltimoSueldoMensOrd
    def get_IngresoAcumulable(self): return self.IngresoAcumulable
    def set_IngresoAcumulable(self, IngresoAcumulable): self.IngresoAcumulable = IngresoAcumulable
    def get_IngresoNoAcumulable(self): return self.IngresoNoAcumulable
    def set_IngresoNoAcumulable(self, IngresoNoAcumulable): self.IngresoNoAcumulable = IngresoNoAcumulable
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='SeparacionIndemnizacionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SeparacionIndemnizacionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='SeparacionIndemnizacionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='SeparacionIndemnizacionType'):
        if self.TotalPagado is not None and 'TotalPagado' not in already_processed:
            already_processed.add('TotalPagado')
            outfile.write(' TotalPagado=%s' % (quote_attrib(self.TotalPagado), ))
        if self.NumAnosServicio is not None and u'NumAñosServicio' not in already_processed:
            already_processed.add(u'NumAñosServicio')
            outfile.write(u' NumAñosServicio="%s"' % self.gds_format_integer(self.NumAnosServicio, input_name=u'NumAñosServicio'))
        if self.UltimoSueldoMensOrd is not None and 'UltimoSueldoMensOrd' not in already_processed:
            already_processed.add('UltimoSueldoMensOrd')
            outfile.write(' UltimoSueldoMensOrd=%s' % (quote_attrib(self.UltimoSueldoMensOrd), ))
        if self.IngresoAcumulable is not None and 'IngresoAcumulable' not in already_processed:
            already_processed.add('IngresoAcumulable')
            outfile.write(' IngresoAcumulable=%s' % (quote_attrib(self.IngresoAcumulable), ))
        if self.IngresoNoAcumulable is not None and 'IngresoNoAcumulable' not in already_processed:
            already_processed.add('IngresoNoAcumulable')
            outfile.write(' IngresoNoAcumulable=%s' % (quote_attrib(self.IngresoNoAcumulable), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='SeparacionIndemnizacionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TotalPagado', node)
        if value is not None and 'TotalPagado' not in already_processed:
            already_processed.add('TotalPagado')
            self.TotalPagado = value
        value = find_attr_value_(u'NumAñosServicio', node)
        if value is not None and u'NumAñosServicio' not in already_processed:
            already_processed.add(u'NumAñosServicio')
            try:
                self.NumAnosServicio = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('UltimoSueldoMensOrd', node)
        if value is not None and 'UltimoSueldoMensOrd' not in already_processed:
            already_processed.add('UltimoSueldoMensOrd')
            self.UltimoSueldoMensOrd = value
        value = find_attr_value_('IngresoAcumulable', node)
        if value is not None and 'IngresoAcumulable' not in already_processed:
            already_processed.add('IngresoAcumulable')
            self.IngresoAcumulable = value
        value = find_attr_value_('IngresoNoAcumulable', node)
        if value is not None and 'IngresoNoAcumulable' not in already_processed:
            already_processed.add('IngresoNoAcumulable')
            self.IngresoNoAcumulable = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SeparacionIndemnizacionType


class DeduccionesType(GeneratedsSuper):
    """Atributo condicional para expresar el total de deducciones que se
    relacionan en el comprobante, donde la clave de tipo de
    deducción sea distinta a la 002 correspondiente a ISR.Atributo
    condicional para expresar el total de los impuestos federales
    retenidos, es decir, donde la clave de tipo de deducción sea 002
    correspondiente a ISR."""
    subclass = None
    superclass = None
    def __init__(self, TotalOtrasDeducciones=None, TotalImpuestosRetenidos=None, Deduccion=None):
        self.original_tagname_ = None
        self.TotalOtrasDeducciones = _cast(None, TotalOtrasDeducciones)
        self.TotalImpuestosRetenidos = _cast(None, TotalImpuestosRetenidos)
        if Deduccion is None:
            self.Deduccion = []
        else:
            self.Deduccion = Deduccion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeduccionesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeduccionesType.subclass:
            return DeduccionesType.subclass(*args_, **kwargs_)
        else:
            return DeduccionesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Deduccion(self): return self.Deduccion
    def set_Deduccion(self, Deduccion): self.Deduccion = Deduccion
    def add_Deduccion(self, value): self.Deduccion.append(value)
    def insert_Deduccion_at(self, index, value): self.Deduccion.insert(index, value)
    def replace_Deduccion_at(self, index, value): self.Deduccion[index] = value
    def get_TotalOtrasDeducciones(self): return self.TotalOtrasDeducciones
    def set_TotalOtrasDeducciones(self, TotalOtrasDeducciones): self.TotalOtrasDeducciones = TotalOtrasDeducciones
    def get_TotalImpuestosRetenidos(self): return self.TotalImpuestosRetenidos
    def set_TotalImpuestosRetenidos(self, TotalImpuestosRetenidos): self.TotalImpuestosRetenidos = TotalImpuestosRetenidos
    def hasContent_(self):
        if (
            self.Deduccion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='DeduccionesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeduccionesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='DeduccionesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='DeduccionesType'):
        if self.TotalOtrasDeducciones is not None and 'TotalOtrasDeducciones' not in already_processed:
            already_processed.add('TotalOtrasDeducciones')
            outfile.write(' TotalOtrasDeducciones=%s' % (quote_attrib(self.TotalOtrasDeducciones), ))
        if self.TotalImpuestosRetenidos is not None and 'TotalImpuestosRetenidos' not in already_processed:
            already_processed.add('TotalImpuestosRetenidos')
            outfile.write(' TotalImpuestosRetenidos=%s' % (quote_attrib(self.TotalImpuestosRetenidos), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='DeduccionesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Deduccion_ in self.Deduccion:
            Deduccion_.export(outfile, level, namespace_, name_='Deduccion', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TotalOtrasDeducciones', node)
        if value is not None and 'TotalOtrasDeducciones' not in already_processed:
            already_processed.add('TotalOtrasDeducciones')
            self.TotalOtrasDeducciones = value
        value = find_attr_value_('TotalImpuestosRetenidos', node)
        if value is not None and 'TotalImpuestosRetenidos' not in already_processed:
            already_processed.add('TotalImpuestosRetenidos')
            self.TotalImpuestosRetenidos = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Deduccion':
            obj_ = DeduccionType.factory()
            obj_.build(child_)
            self.Deduccion.append(obj_)
            obj_.original_tagname_ = 'Deduccion'
# end class DeduccionesType


class DeduccionType(GeneratedsSuper):
    """Atributo requerido para registrar la clave agrupadora que clasifica
    la deducción.Atributo requerido para la clave de deducción de
    nómina propia de la contabilidad de cada patrón, puede
    conformarse desde 3 hasta 15 caracteres.Atributo requerido para
    la descripción del concepto de deducción.Atributo requerido para
    registrar el importe del concepto de deducción."""
    subclass = None
    superclass = None
    def __init__(self, TipoDeduccion=None, Clave=None, Concepto=None, Importe=None):
        self.original_tagname_ = None
        self.TipoDeduccion = _cast(None, TipoDeduccion)
        try:
            self.Clave = _cast(None, Clave.strip())
        except:
            self.Clave = _cast(None, Clave)
        self.Concepto = _cast(None, Concepto)
        self.Importe = _cast(None, Importe)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeduccionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeduccionType.subclass:
            return DeduccionType.subclass(*args_, **kwargs_)
        else:
            return DeduccionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TipoDeduccion(self): return self.TipoDeduccion
    def set_TipoDeduccion(self, TipoDeduccion): self.TipoDeduccion = TipoDeduccion
    def get_Clave(self): return self.Clave
    def set_Clave(self, Clave): self.Clave = Clave
    def get_Concepto(self): return self.Concepto
    def set_Concepto(self, Concepto): self.Concepto = Concepto
    def get_Importe(self): return self.Importe
    def set_Importe(self, Importe): self.Importe = Importe
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='DeduccionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeduccionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='DeduccionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='DeduccionType'):
        if self.TipoDeduccion is not None and 'TipoDeduccion' not in already_processed:
            already_processed.add('TipoDeduccion')
            outfile.write(' TipoDeduccion=%s' % (quote_attrib(self.TipoDeduccion), ))
        if self.Clave is not None and 'Clave' not in already_processed:
            already_processed.add('Clave')
            outfile.write(' Clave=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Clave), input_name='Clave')), ))
        if self.Concepto is not None and 'Concepto' not in already_processed:
            already_processed.add('Concepto')
            outfile.write(' Concepto=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Concepto), input_name='Concepto')), ))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe=%s' % (quote_attrib(self.Importe), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='DeduccionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TipoDeduccion', node)
        if value is not None and 'TipoDeduccion' not in already_processed:
            already_processed.add('TipoDeduccion')
            self.TipoDeduccion = value
        value = find_attr_value_('Clave', node)
        if value is not None and 'Clave' not in already_processed:
            already_processed.add('Clave')
            self.Clave = value
        value = find_attr_value_('Concepto', node)
        if value is not None and 'Concepto' not in already_processed:
            already_processed.add('Concepto')
            self.Concepto = value
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            self.Importe = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DeduccionType


class OtrosPagosType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OtroPago=None):
        self.original_tagname_ = None
        if OtroPago is None:
            self.OtroPago = []
        else:
            self.OtroPago = OtroPago
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtrosPagosType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtrosPagosType.subclass:
            return OtrosPagosType.subclass(*args_, **kwargs_)
        else:
            return OtrosPagosType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OtroPago(self): return self.OtroPago
    def set_OtroPago(self, OtroPago): self.OtroPago = OtroPago
    def add_OtroPago(self, value): self.OtroPago.append(value)
    def insert_OtroPago_at(self, index, value): self.OtroPago.insert(index, value)
    def replace_OtroPago_at(self, index, value): self.OtroPago[index] = value
    def hasContent_(self):
        if (
            self.OtroPago
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='OtrosPagosType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtrosPagosType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='OtrosPagosType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='OtrosPagosType'):
        pass
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='OtrosPagosType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OtroPago_ in self.OtroPago:
            OtroPago_.export(outfile, level, namespace_, name_='OtroPago', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OtroPago':
            obj_ = OtroPagoType.factory()
            obj_.build(child_)
            self.OtroPago.append(obj_)
            obj_.original_tagname_ = 'OtroPago'
# end class OtrosPagosType


class OtroPagoType(GeneratedsSuper):
    """Atributo requerido para expresar la clave agrupadora bajo la cual se
    clasifica el otro pago.Atributo requerido, representa la clave
    de otro pago de nómina propia de la contabilidad de cada patrón,
    puede conformarse desde 3 hasta 15 caracteres.Atributo requerido
    para la descripción del concepto de otro pago.Atributo requerido
    para expresar el importe del concepto de otro pago."""
    subclass = None
    superclass = None
    def __init__(self, TipoOtroPago=None, Clave=None, Concepto=None, Importe=None, SubsidioAlEmpleo=None, CompensacionSaldosAFavor=None):
        self.original_tagname_ = None
        try:
            self.TipoOtroPago = _cast(None, TipoOtroPago.strip())
        except:
            self.TipoOtroPago = _cast(None, TipoOtroPago)
        self.Clave = _cast(None, Clave)
        self.Concepto = _cast(None, Concepto)
        self.Importe = _cast(None, Importe)
        self.SubsidioAlEmpleo = SubsidioAlEmpleo
        self.CompensacionSaldosAFavor = CompensacionSaldosAFavor
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OtroPagoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OtroPagoType.subclass:
            return OtroPagoType.subclass(*args_, **kwargs_)
        else:
            return OtroPagoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubsidioAlEmpleo(self): return self.SubsidioAlEmpleo
    def set_SubsidioAlEmpleo(self, SubsidioAlEmpleo): self.SubsidioAlEmpleo = SubsidioAlEmpleo
    def get_CompensacionSaldosAFavor(self): return self.CompensacionSaldosAFavor
    def set_CompensacionSaldosAFavor(self, CompensacionSaldosAFavor): self.CompensacionSaldosAFavor = CompensacionSaldosAFavor
    def get_TipoOtroPago(self): return self.TipoOtroPago
    def set_TipoOtroPago(self, TipoOtroPago): self.TipoOtroPago = TipoOtroPago
    def get_Clave(self): return self.Clave
    def set_Clave(self, Clave): self.Clave = Clave
    def get_Concepto(self): return self.Concepto
    def set_Concepto(self, Concepto): self.Concepto = Concepto
    def get_Importe(self): return self.Importe
    def set_Importe(self, Importe): self.Importe = Importe
    def hasContent_(self):
        if (
            self.SubsidioAlEmpleo is not None or
            self.CompensacionSaldosAFavor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='OtroPagoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OtroPagoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='OtroPagoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='OtroPagoType'):
        if self.TipoOtroPago is not None and 'TipoOtroPago' not in already_processed:
            already_processed.add('TipoOtroPago')
            outfile.write(' TipoOtroPago=%s' % (quote_attrib(self.TipoOtroPago), ))
        if self.Clave is not None and 'Clave' not in already_processed:
            already_processed.add('Clave')
            outfile.write(' Clave=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Clave), input_name='Clave')), ))
        if self.Concepto is not None and 'Concepto' not in already_processed:
            already_processed.add('Concepto')
            outfile.write(' Concepto=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Concepto), input_name='Concepto')), ))
        if self.Importe is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            outfile.write(' Importe=%s' % (quote_attrib(self.Importe), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='OtroPagoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SubsidioAlEmpleo is not None:
            self.SubsidioAlEmpleo.export(outfile, level, namespace_, name_='SubsidioAlEmpleo', pretty_print=pretty_print)
        if self.CompensacionSaldosAFavor is not None:
            self.CompensacionSaldosAFavor.export(outfile, level, namespace_, name_='CompensacionSaldosAFavor', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TipoOtroPago', node)
        if value is not None and 'TipoOtroPago' not in already_processed:
            already_processed.add('TipoOtroPago')
            self.TipoOtroPago = value
        value = find_attr_value_('Clave', node)
        if value is not None and 'Clave' not in already_processed:
            already_processed.add('Clave')
            self.Clave = value
        value = find_attr_value_('Concepto', node)
        if value is not None and 'Concepto' not in already_processed:
            already_processed.add('Concepto')
            self.Concepto = value
        value = find_attr_value_('Importe', node)
        if value is not None and 'Importe' not in already_processed:
            already_processed.add('Importe')
            self.Importe = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubsidioAlEmpleo':
            obj_ = SubsidioAlEmpleoType.factory()
            obj_.build(child_)
            self.SubsidioAlEmpleo = obj_
            obj_.original_tagname_ = 'SubsidioAlEmpleo'
        elif nodeName_ == 'CompensacionSaldosAFavor':
            obj_ = CompensacionSaldosAFavorType.factory()
            obj_.build(child_)
            self.CompensacionSaldosAFavor = obj_
            obj_.original_tagname_ = 'CompensacionSaldosAFavor'
# end class OtroPagoType


class SubsidioAlEmpleoType(GeneratedsSuper):
    """Atributo requerido para expresar el subsidio causado conforme a la
    tabla del subsidio para el empleo publicada en el Anexo 8 de la
    RMF vigente."""
    subclass = None
    superclass = None
    def __init__(self, SubsidioCausado=None):
        self.original_tagname_ = None
        self.SubsidioCausado = _cast(None, SubsidioCausado)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubsidioAlEmpleoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubsidioAlEmpleoType.subclass:
            return SubsidioAlEmpleoType.subclass(*args_, **kwargs_)
        else:
            return SubsidioAlEmpleoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubsidioCausado(self): return self.SubsidioCausado
    def set_SubsidioCausado(self, SubsidioCausado): self.SubsidioCausado = SubsidioCausado
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='SubsidioAlEmpleoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubsidioAlEmpleoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='SubsidioAlEmpleoType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='SubsidioAlEmpleoType'):
        if self.SubsidioCausado is not None and 'SubsidioCausado' not in already_processed:
            already_processed.add('SubsidioCausado')
            outfile.write(' SubsidioCausado=%s' % (quote_attrib(self.SubsidioCausado), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='SubsidioAlEmpleoType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SubsidioCausado', node)
        if value is not None and 'SubsidioCausado' not in already_processed:
            already_processed.add('SubsidioCausado')
            self.SubsidioCausado = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SubsidioAlEmpleoType


class CompensacionSaldosAFavorType(GeneratedsSuper):
    """Atributo requerido para expresar el saldo a favor determinado por el
    patrón al trabajador en periodos o ejercicios
    anteriores.Atributo requerido para expresar el año en que se
    determinó el saldo a favor del trabajador por el patrón que se
    incluye en el campo “RemanenteSalFav”.Atributo requerido para
    expresar el remanente del saldo a favor del trabajador."""
    subclass = None
    superclass = None
    def __init__(self, SaldoAFavor=None, Ano=None, RemanenteSalFav=None):
        self.original_tagname_ = None
        self.SaldoAFavor = _cast(None, SaldoAFavor)
        self.Ano = _cast(int, Ano)
        self.RemanenteSalFav = _cast(None, RemanenteSalFav)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CompensacionSaldosAFavorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CompensacionSaldosAFavorType.subclass:
            return CompensacionSaldosAFavorType.subclass(*args_, **kwargs_)
        else:
            return CompensacionSaldosAFavorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SaldoAFavor(self): return self.SaldoAFavor
    def set_SaldoAFavor(self, SaldoAFavor): self.SaldoAFavor = SaldoAFavor
    def get_Ano(self): return self.Ano
    def set_Ano(self, Ano): self.Ano = Ano
    def get_RemanenteSalFav(self): return self.RemanenteSalFav
    def set_RemanenteSalFav(self, RemanenteSalFav): self.RemanenteSalFav = RemanenteSalFav
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='CompensacionSaldosAFavorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompensacionSaldosAFavorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='CompensacionSaldosAFavorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='CompensacionSaldosAFavorType'):
        if self.SaldoAFavor is not None and 'SaldoAFavor' not in already_processed:
            already_processed.add('SaldoAFavor')
            outfile.write(' SaldoAFavor=%s' % (quote_attrib(self.SaldoAFavor), ))
        if self.Ano is not None and u'Año' not in already_processed:
            already_processed.add(u'Año')
            outfile.write(u' Año="%s"' % self.gds_format_integer(self.Ano, input_name=u'Año'))
        if self.RemanenteSalFav is not None and 'RemanenteSalFav' not in already_processed:
            already_processed.add('RemanenteSalFav')
            outfile.write(' RemanenteSalFav=%s' % (quote_attrib(self.RemanenteSalFav), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='CompensacionSaldosAFavorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('SaldoAFavor', node)
        if value is not None and 'SaldoAFavor' not in already_processed:
            already_processed.add('SaldoAFavor')
            self.SaldoAFavor = value
        value = find_attr_value_(u'Año', node)
        if value is not None and u'Año' not in already_processed:
            already_processed.add(u'Año')
            try:
                self.Ano = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('RemanenteSalFav', node)
        if value is not None and 'RemanenteSalFav' not in already_processed:
            already_processed.add('RemanenteSalFav')
            self.RemanenteSalFav = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CompensacionSaldosAFavorType


class IncapacidadesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Incapacidad=None):
        self.original_tagname_ = None
        if Incapacidad is None:
            self.Incapacidad = []
        else:
            self.Incapacidad = Incapacidad
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IncapacidadesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IncapacidadesType.subclass:
            return IncapacidadesType.subclass(*args_, **kwargs_)
        else:
            return IncapacidadesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Incapacidad(self): return self.Incapacidad
    def set_Incapacidad(self, Incapacidad): self.Incapacidad = Incapacidad
    def add_Incapacidad(self, value): self.Incapacidad.append(value)
    def insert_Incapacidad_at(self, index, value): self.Incapacidad.insert(index, value)
    def replace_Incapacidad_at(self, index, value): self.Incapacidad[index] = value
    def hasContent_(self):
        if (
            self.Incapacidad
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='IncapacidadesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IncapacidadesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='IncapacidadesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='IncapacidadesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='IncapacidadesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Incapacidad_ in self.Incapacidad:
            Incapacidad_.export(outfile, level, namespace_, name_='Incapacidad', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Incapacidad':
            obj_ = IncapacidadType.factory()
            obj_.build(child_)
            self.Incapacidad.append(obj_)
            obj_.original_tagname_ = 'Incapacidad'
# end class IncapacidadesType


class IncapacidadType(GeneratedsSuper):
    """Atributo requerido para expresar el número de días enteros que el
    trabajador se incapacitó en el periodo.Atributo requerido para
    expresar la razón de la incapacidad.Atributo condicional para
    expresar el monto del importe monetario de la incapacidad."""
    subclass = None
    superclass = None
    def __init__(self, DiasIncapacidad=None, TipoIncapacidad=None, ImporteMonetario=None):
        self.original_tagname_ = None
        self.DiasIncapacidad = _cast(int, DiasIncapacidad)
        self.TipoIncapacidad = _cast(None, TipoIncapacidad)
        self.ImporteMonetario = _cast(None, ImporteMonetario)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IncapacidadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IncapacidadType.subclass:
            return IncapacidadType.subclass(*args_, **kwargs_)
        else:
            return IncapacidadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DiasIncapacidad(self): return self.DiasIncapacidad
    def set_DiasIncapacidad(self, DiasIncapacidad): self.DiasIncapacidad = DiasIncapacidad
    def get_TipoIncapacidad(self): return self.TipoIncapacidad
    def set_TipoIncapacidad(self, TipoIncapacidad): self.TipoIncapacidad = TipoIncapacidad
    def get_ImporteMonetario(self): return self.ImporteMonetario
    def set_ImporteMonetario(self, ImporteMonetario): self.ImporteMonetario = ImporteMonetario
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='nomina12:', name_='IncapacidadType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IncapacidadType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='nomina12:', name_='IncapacidadType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='nomina12:', name_='IncapacidadType'):
        if self.DiasIncapacidad is not None and 'DiasIncapacidad' not in already_processed:
            already_processed.add('DiasIncapacidad')
            outfile.write(' DiasIncapacidad="%s"' % self.gds_format_integer(self.DiasIncapacidad, input_name='DiasIncapacidad'))
        if self.TipoIncapacidad is not None and 'TipoIncapacidad' not in already_processed:
            already_processed.add('TipoIncapacidad')
            outfile.write(' TipoIncapacidad=%s' % (quote_attrib(self.TipoIncapacidad), ))
        if self.ImporteMonetario is not None and 'ImporteMonetario' not in already_processed:
            already_processed.add('ImporteMonetario')
            outfile.write(' ImporteMonetario=%s' % (quote_attrib(self.ImporteMonetario), ))
    def exportChildren(self, outfile, level, namespace_='nomina12:', name_='IncapacidadType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('DiasIncapacidad', node)
        if value is not None and 'DiasIncapacidad' not in already_processed:
            already_processed.add('DiasIncapacidad')
            try:
                self.DiasIncapacidad = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('TipoIncapacidad', node)
        if value is not None and 'TipoIncapacidad' not in already_processed:
            already_processed.add('TipoIncapacidad')
            self.TipoIncapacidad = value
        value = find_attr_value_('ImporteMonetario', node)
        if value is not None and 'ImporteMonetario' not in already_processed:
            already_processed.add('ImporteMonetario')
            self.ImporteMonetario = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IncapacidadType


GDSClassesMapping = {
    'AccionesOTitulos': AccionesOTitulosType,
    'CompensacionSaldosAFavor': CompensacionSaldosAFavorType,
    'Deduccion': DeduccionType,
    'Deducciones': DeduccionesType,
    'Emisor': EmisorType,
    'EntidadSNCF': EntidadSNCFType,
    'HorasExtra': HorasExtraType,
    'Incapacidad': IncapacidadType,
    'Incapacidades': IncapacidadesType,
    'JubilacionPensionRetiro': JubilacionPensionRetiroType,
    'OtroPago': OtroPagoType,
    'OtrosPagos': OtrosPagosType,
    'Percepcion': PercepcionType,
    'Percepciones': PercepcionesType,
    'Receptor': ReceptorType,
    'SeparacionIndemnizacion': SeparacionIndemnizacionType,
    'SubContratacion': SubContratacionType,
    'SubsidioAlEmpleo': SubsidioAlEmpleoType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Nomina'
        rootClass = Nomina
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            # namespacedef_='xmlns:finkok="http://www.finkok.com"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Nomina'
        rootClass = Nomina
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    if sys.version_info.major == 2:
        from StringIO import StringIO as IOBuffer
    else:
        from io import BytesIO as IOBuffer
    parser = None
    doc = parsexml_(IOBuffer(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Nomina'
        rootClass = Nomina
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            # namespacedef_='xmlns:finkok="http://www.finkok.com"'
        )
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Nomina'
        rootClass = Nomina
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from nomina12 import *\n\n')
        sys.stdout.write('import nomina12 as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AccionesOTitulosType",
    "CompensacionSaldosAFavorType",
    "DeduccionType",
    "DeduccionesType",
    "EmisorType",
    "EntidadSNCFType",
    "HorasExtraType",
    "IncapacidadType",
    "IncapacidadesType",
    "JubilacionPensionRetiroType",
    "Nomina",
    "OtroPagoType",
    "OtrosPagosType",
    "PercepcionType",
    "PercepcionesType",
    "ReceptorType",
    "SeparacionIndemnizacionType",
    "SubContratacionType",
    "SubsidioAlEmpleoType"
]
